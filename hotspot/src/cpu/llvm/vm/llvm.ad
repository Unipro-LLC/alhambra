//
// Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//



// Elbrus Architecture Description File

//----------REGISTER DEFINITION BLOCK------------------------------------------
// This information is used by the matcher and the register allocator to
// describe individual registers and classes of registers within the target
// archtecture.

register %{

//----------Architecture Description Register Definitions----------------------
// General Registers
// "reg_def"  name ( register save type, C convention save type,
//                   ideal register type, encoding, vm name );
// Register Save Types:
//
// NS  = No-Save:       The register allocator assumes that these registers
//                      can be used without saving upon entry to the method, &
//                      that they do not need to be saved at call sites.
//
// SOC = Save-On-Call:  The register allocator assumes that these registers
//                      can be used without saving upon entry to the method,
//                      but that they must be saved at call sites.
//
// SOE = Save-On-Entry: The register allocator assumes that these registers
//                      must be saved before using them upon entry to the
//                      method, but they do not need to be saved at call
//                      sites.
//
// AS  = Always-Save:   The register allocator assumes that these registers
//                      must be saved before using them upon entry to the
//                      method, & that they must be saved at call sites.
//
// Ideal Register Type is used to determine how to save & restore a
// register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
// spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
//
// The encoding number is the actual bit-pattern placed into the opcodes.



// Global Registers 0-15
reg_def GR_0 (NS, NS, Op_RegI, 0  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_1 (NS, NS, Op_RegI, 1  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_2 (NS, NS, Op_RegI, 2  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_3 (NS, NS, Op_RegI, 3  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_4 (NS, NS, Op_RegI, 4  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_5 (NS, NS, Op_RegI, 5  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_6 (NS, NS, Op_RegI, 6  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_7 (NS, NS, Op_RegI, 7  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_8 (NS, NS, Op_RegI, 8  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_9 (NS, NS, Op_RegI, 9  | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_10(NS, NS, Op_RegI, 10 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_11(NS, NS, Op_RegI, 11 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_12(NS, NS, Op_RegI, 12 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_13(NS, NS, Op_RegI, 13 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_14(NS, NS, Op_RegI, 14 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def GR_15(NS, NS, Op_RegI, 15 | 128 | 64 | 32, VMRegImpl::Bad());

// Window Registers 0-63
reg_def R_0 (NS, NS, Op_RegI,  0  | 128, VMRegImpl::Bad());
reg_def R_1 (NS, NS, Op_RegI,  1  | 128, VMRegImpl::Bad());
reg_def R_2 (NS, NS, Op_RegI,  2  | 128, VMRegImpl::Bad());
reg_def R_3 (NS, NS, Op_RegI,  3  | 128, VMRegImpl::Bad());
reg_def R_4 (NS, NS, Op_RegI,  4  | 128, VMRegImpl::Bad());
reg_def R_5 (NS, NS, Op_RegI,  5  | 128, VMRegImpl::Bad());
reg_def R_6 (NS, NS, Op_RegI,  6  | 128, VMRegImpl::Bad());
reg_def R_7 (NS, NS, Op_RegI,  7  | 128, VMRegImpl::Bad());
reg_def R_8 (NS, NS, Op_RegI,  8  | 128, VMRegImpl::Bad());
reg_def R_9 (NS, NS, Op_RegI,  9  | 128, VMRegImpl::Bad());
reg_def R_10(NS, NS, Op_RegI,  10 | 128, VMRegImpl::Bad());
reg_def R_11(NS, NS, Op_RegI,  11 | 128, VMRegImpl::Bad());
reg_def R_12(NS, NS, Op_RegI,  12 | 128, VMRegImpl::Bad());
reg_def R_13(NS, NS, Op_RegI,  13 | 128, VMRegImpl::Bad());
reg_def R_14(NS, NS, Op_RegI,  14 | 128, VMRegImpl::Bad());
reg_def R_15(NS, NS, Op_RegI,  15 | 128, VMRegImpl::Bad());
reg_def R_16(NS, NS, Op_RegI,  16 | 128, VMRegImpl::Bad());
reg_def R_17(NS, NS, Op_RegI,  17 | 128, VMRegImpl::Bad());
reg_def R_18(NS, NS, Op_RegI,  18 | 128, VMRegImpl::Bad());
reg_def R_19(NS, NS, Op_RegI,  19 | 128, VMRegImpl::Bad());
reg_def R_20(NS, NS, Op_RegI,  20 | 128, VMRegImpl::Bad());
reg_def R_21(NS, NS, Op_RegI,  21 | 128, VMRegImpl::Bad());
reg_def R_22(NS, NS, Op_RegI,  22 | 128, VMRegImpl::Bad());
reg_def R_23(NS, NS, Op_RegI,  23 | 128, VMRegImpl::Bad());
reg_def R_24(NS, NS, Op_RegI,  24 | 128, VMRegImpl::Bad());
reg_def R_25(NS, NS, Op_RegI,  25 | 128, VMRegImpl::Bad());
reg_def R_26(NS, NS, Op_RegI,  26 | 128, VMRegImpl::Bad());
reg_def R_27(NS, NS, Op_RegI,  27 | 128, VMRegImpl::Bad());
reg_def R_28(NS, NS, Op_RegI,  28 | 128, VMRegImpl::Bad());
reg_def R_29(NS, NS, Op_RegI,  29 | 128, VMRegImpl::Bad());
reg_def R_30(NS, NS, Op_RegI,  30 | 128, VMRegImpl::Bad());
reg_def R_31(NS, NS, Op_RegI,  31 | 128, VMRegImpl::Bad());
reg_def R_32(NS, NS, Op_RegI,  32 | 128, VMRegImpl::Bad());
reg_def R_33(NS, NS, Op_RegI,  33 | 128, VMRegImpl::Bad());
reg_def R_34(NS, NS, Op_RegI,  34 | 128, VMRegImpl::Bad());
reg_def R_35(NS, NS, Op_RegI,  35 | 128, VMRegImpl::Bad());
reg_def R_36(NS, NS, Op_RegI,  36 | 128, VMRegImpl::Bad());
reg_def R_37(NS, NS, Op_RegI,  37 | 128, VMRegImpl::Bad());
reg_def R_38(NS, NS, Op_RegI,  38 | 128, VMRegImpl::Bad());
reg_def R_39(NS, NS, Op_RegI,  39 | 128, VMRegImpl::Bad());
reg_def R_40(NS, NS, Op_RegI,  40 | 128, VMRegImpl::Bad());
reg_def R_41(NS, NS, Op_RegI,  41 | 128, VMRegImpl::Bad());
reg_def R_42(NS, NS, Op_RegI,  42 | 128, VMRegImpl::Bad());
reg_def R_43(NS, NS, Op_RegI,  43 | 128, VMRegImpl::Bad());
reg_def R_44(NS, NS, Op_RegI,  44 | 128, VMRegImpl::Bad());
reg_def R_45(NS, NS, Op_RegI,  45 | 128, VMRegImpl::Bad());
reg_def R_46(NS, NS, Op_RegI,  46 | 128, VMRegImpl::Bad());
reg_def R_47(NS, NS, Op_RegI,  47 | 128, VMRegImpl::Bad());
reg_def R_48(NS, NS, Op_RegI,  48 | 128, VMRegImpl::Bad());
reg_def R_49(NS, NS, Op_RegI,  49 | 128, VMRegImpl::Bad());
reg_def R_50(NS, NS, Op_RegI,  50 | 128, VMRegImpl::Bad());
reg_def R_51(NS, NS, Op_RegI,  51 | 128, VMRegImpl::Bad());
reg_def R_52(NS, NS, Op_RegI,  52 | 128, VMRegImpl::Bad());
reg_def R_53(NS, NS, Op_RegI,  53 | 128, VMRegImpl::Bad());
reg_def R_54(NS, NS, Op_RegI,  54 | 128, VMRegImpl::Bad());
reg_def R_55(NS, NS, Op_RegI,  55 | 128, VMRegImpl::Bad());
reg_def R_56(NS, NS, Op_RegI,  56 | 128, VMRegImpl::Bad());
reg_def R_57(NS, NS, Op_RegI,  57 | 128, VMRegImpl::Bad());
reg_def R_58(NS, NS, Op_RegI,  58 | 128, VMRegImpl::Bad());
reg_def R_59(NS, NS, Op_RegI,  59 | 128, VMRegImpl::Bad());
reg_def R_60(NS, NS, Op_RegI,  60 | 128, VMRegImpl::Bad());
reg_def R_61(NS, NS, Op_RegI,  61 | 128, VMRegImpl::Bad());
reg_def R_62(NS, NS, Op_RegI,  62 | 128, VMRegImpl::Bad());
reg_def R_63(NS, NS, Op_RegI,  63 | 128, VMRegImpl::Bad());

// Rotate Registers, using for out params
reg_def BR_0(SOC, SOC, Op_RegI, 0, VMRegImpl::Bad());
reg_def BR_1(SOC, SOC, Op_RegI, 1, VMRegImpl::Bad());
reg_def BR_2(SOC, SOC, Op_RegI, 2, VMRegImpl::Bad());
reg_def BR_3(SOC, SOC, Op_RegI, 3, VMRegImpl::Bad());
reg_def BR_4(SOC, SOC, Op_RegI, 4, VMRegImpl::Bad());
reg_def BR_5(SOC, SOC, Op_RegI, 5, VMRegImpl::Bad());
reg_def BR_6(SOC, SOC, Op_RegI, 6, VMRegImpl::Bad());
reg_def BR_7(SOC, SOC, Op_RegI, 7, VMRegImpl::Bad());

//Predicate registers
reg_def PR_0(NS, NS, Op_RegFlags, 0, VMRegImpl::Bad());
reg_def PR_1(NS, NS, Op_RegFlags, 1, VMRegImpl::Bad());
reg_def PR_2(NS, NS, Op_RegFlags, 2, VMRegImpl::Bad());
reg_def PR_3(NS, NS, Op_RegFlags, 3, VMRegImpl::Bad());
reg_def PR_4(NS, NS, Op_RegFlags, 4, VMRegImpl::Bad());
reg_def PR_5(NS, NS, Op_RegFlags, 5, VMRegImpl::Bad());
reg_def PR_6(NS, NS, Op_RegFlags, 6, VMRegImpl::Bad());
reg_def PR_7(NS, NS, Op_RegFlags, 7, VMRegImpl::Bad());
reg_def PR_8(NS, NS, Op_RegFlags, 8, VMRegImpl::Bad());
reg_def PR_9(NS, NS, Op_RegFlags, 9, VMRegImpl::Bad());
reg_def PR_10(NS, NS, Op_RegFlags, 10, VMRegImpl::Bad());
reg_def PR_11(NS, NS, Op_RegFlags, 11, VMRegImpl::Bad());
reg_def PR_12(NS, NS, Op_RegFlags, 12, VMRegImpl::Bad());
reg_def PR_13(NS, NS, Op_RegFlags, 13, VMRegImpl::Bad());
reg_def PR_14(NS, NS, Op_RegFlags, 14, VMRegImpl::Bad());
reg_def PR_15(NS, NS, Op_RegFlags, 15, VMRegImpl::Bad());
reg_def PR_16(NS, NS, Op_RegFlags, 16, VMRegImpl::Bad());
reg_def PR_17(NS, NS, Op_RegFlags, 17, VMRegImpl::Bad());
reg_def PR_18(NS, NS, Op_RegFlags, 18, VMRegImpl::Bad());
reg_def PR_19(NS, NS, Op_RegFlags, 19, VMRegImpl::Bad());
reg_def PR_20(NS, NS, Op_RegFlags, 20, VMRegImpl::Bad());
reg_def PR_21(NS, NS, Op_RegFlags, 21, VMRegImpl::Bad());
reg_def PR_22(NS, NS, Op_RegFlags, 22, VMRegImpl::Bad());
reg_def PR_23(NS, NS, Op_RegFlags, 23, VMRegImpl::Bad());
reg_def PR_24(NS, NS, Op_RegFlags, 24, VMRegImpl::Bad());
reg_def PR_25(NS, NS, Op_RegFlags, 25, VMRegImpl::Bad());
reg_def PR_26(NS, NS, Op_RegFlags, 26, VMRegImpl::Bad());
reg_def PR_27(NS, NS, Op_RegFlags, 27, VMRegImpl::Bad());
reg_def PR_28(NS, NS, Op_RegFlags, 28, VMRegImpl::Bad());
reg_def PR_29(NS, NS, Op_RegFlags, 29, VMRegImpl::Bad());
reg_def PR_30(NS, NS, Op_RegFlags, 30, VMRegImpl::Bad());
reg_def PR_31(NS, NS, Op_RegFlags, 31, VMRegImpl::Bad());

//Scratch registers
reg_def SR_0  (SOC, SOC, Op_RegI,  16 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_1  (SOC, SOC, Op_RegI,  17 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_2  (SOC, SOC, Op_RegI,  18 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_3  (SOC, SOC, Op_RegI,  19 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_4  (SOC, SOC, Op_RegI,  20 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_5  (SOC, SOC, Op_RegI,  21 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_6  (SOC, SOC, Op_RegI,  22 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_7  (SOC, SOC, Op_RegI,  23 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_8  (SOC, SOC, Op_RegI,  24 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_9  (SOC, SOC, Op_RegI,  25 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_10 (SOC, SOC, Op_RegI,  26 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_11 (SOC, SOC, Op_RegI,  27 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_12 (SOC, SOC, Op_RegI,  28 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_13 (SOC, SOC, Op_RegI,  29 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_14 (SOC, SOC, Op_RegI,  30 | 128 | 64 | 32, VMRegImpl::Bad());
reg_def SR_15 (SOC, SOC, Op_RegI,  31 | 128 | 64 | 32, VMRegImpl::Bad());

alloc_class chunk0(
    R_0, R_1, R_2, R_3, R_4, R_5, R_6, R_7,
    R_8, R_9, R_10, R_11, R_12, R_13, R_14, R_15,
    R_16, R_17, R_18, R_19, R_20, R_21, R_22, R_23,
    R_24, R_25, R_26, R_27, R_28, R_29, R_30, R_31,
    R_32, R_33, R_34, R_35, R_36, R_37, R_38, R_39,
    R_40, R_41, R_42, R_43, R_44, R_45, R_46, R_47,
    R_48, R_49, R_50, R_51, R_52, R_53, R_54, R_55,
    R_56, R_57, R_58, R_59, R_60, R_61, R_62, R_63
);

alloc_class chunk1(
    SR_0, SR_1, SR_2, SR_3, SR_4, SR_5, SR_6, SR_7,
    SR_8, SR_9, SR_10, SR_11, SR_12, SR_13, SR_14, SR_15
);

alloc_class chunk2(
    PR_0, PR_1, PR_2, PR_3, PR_4, PR_5, PR_6, PR_7,
    PR_8, PR_9, PR_10, PR_11, PR_12, PR_13, PR_14, PR_15,
    PR_16, PR_17, PR_18, PR_19, PR_20, PR_21, PR_22, PR_23,
    PR_24, PR_25, PR_26, PR_27, PR_28, PR_29, PR_30, PR_31
);

alloc_class chunk3(
    GR_0, GR_1, GR_2, GR_3, GR_4, GR_5, GR_6, GR_7,
    GR_8, GR_9, GR_10, GR_11, GR_12, GR_13, GR_14, GR_15
);

alloc_class chunk4(
    BR_0, BR_1, BR_2, BR_3, BR_4, BR_5, BR_6, BR_7
);

reg_class global_reg(
    GR_0, GR_1, GR_2, GR_3, GR_4, GR_5, GR_6, GR_7,
    GR_8, GR_9, GR_10, GR_11, GR_12, GR_13, GR_14, GR_15
);

reg_class rotate_reg(
    BR_0, BR_1, BR_2, BR_3, BR_4, BR_5, BR_6, BR_7
);

reg_class int_reg(
    R_0, R_1, R_2, R_3, R_4, R_5, R_6, R_7,
    R_8, R_9, R_10, R_11, R_12, R_13, R_14, R_15,
    R_16, R_17, R_18, R_19, R_20, R_21, R_22, R_23,
    R_24, R_25, R_26, R_27, R_28, R_29, R_30, R_31,
    R_32, R_33, R_34, R_35, R_36, R_37, R_38, R_39,
    R_40, R_41, R_42, R_43, R_44, R_45, R_46, R_47,
    R_48, R_49, R_50, R_51, R_52, R_53, R_54, R_55,
    R_56, R_57, R_58, R_59, R_60, R_61, R_62, R_63,
    // scratch regs
    SR_0, SR_1, SR_2, SR_3, SR_4, SR_5, SR_6, SR_7,
    SR_8, SR_9, SR_10, SR_11, SR_12, SR_13, SR_14, SR_15
);

reg_class ptr_reg(
    R_0, R_1, R_2, R_3, R_4, R_5, R_6, R_7,
    R_8, R_9, R_10, R_11, R_12, R_13, R_14, R_15,
    R_16, R_17, R_18, R_19, R_20, R_21, R_22, R_23,
    R_24, R_25, R_26, R_27, R_28, R_29, R_30, R_31,
    R_32, R_33, R_34, R_35, R_36, R_37, R_38, R_39,
    R_40, R_41, R_42, R_43, R_44, R_45, R_46, R_47,
    R_48, R_49, R_50, R_51, R_52, R_53, R_54, R_55,
    R_56, R_57, R_58, R_59, R_60, R_61, R_62, R_63,
    // scratch regs
    SR_0, SR_1, SR_2, SR_3, SR_4, SR_5, SR_6, SR_7,
    SR_8, SR_9, SR_10, SR_11, SR_12, SR_13, SR_14, SR_15
);

reg_class long_reg(
    R_0, R_1, R_2, R_3, R_4, R_5, R_6, R_7,
    R_8, R_9, R_10, R_11, R_12, R_13, R_14, R_15,
    R_16, R_17, R_18, R_19, R_20, R_21, R_22, R_23,
    R_24, R_25, R_26, R_27, R_28, R_29, R_30, R_31,
    R_32, R_33, R_34, R_35, R_36, R_37, R_38, R_39,
    R_40, R_41, R_42, R_43, R_44, R_45, R_46, R_47,
    R_48, R_49, R_50, R_51, R_52, R_53, R_54, R_55,
    R_56, R_57, R_58, R_59, R_60, R_61, R_62, R_63,
    // scratch regs
    SR_0, SR_1, SR_2, SR_3, SR_4, SR_5, SR_6, SR_7,
    SR_8, SR_9, SR_10, SR_11, SR_12, SR_13, SR_14, SR_15
);

reg_class float_reg(
    R_0, R_1, R_2, R_3, R_4, R_5, R_6, R_7,
    R_8, R_9, R_10, R_11, R_12, R_13, R_14, R_15,
    R_16, R_17, R_18, R_19, R_20, R_21, R_22, R_23,
    R_24, R_25, R_26, R_27, R_28, R_29, R_30, R_31,
    R_32, R_33, R_34, R_35, R_36, R_37, R_38, R_39,
    R_40, R_41, R_42, R_43, R_44, R_45, R_46, R_47,
    R_48, R_49, R_50, R_51, R_52, R_53, R_54, R_55,
    R_56, R_57, R_58, R_59, R_60, R_61, R_62, R_63,
    // scratch regs
    SR_0, SR_1, SR_2, SR_3, SR_4, SR_5, SR_6, SR_7,
    SR_8, SR_9, SR_10, SR_11, SR_12, SR_13, SR_14, SR_15
);

reg_class double_reg(
    R_0, R_1, R_2, R_3, R_4, R_5, R_6, R_7,
    R_8, R_9, R_10, R_11, R_12, R_13, R_14, R_15,
    R_16, R_17, R_18, R_19, R_20, R_21, R_22, R_23,
    R_24, R_25, R_26, R_27, R_28, R_29, R_30, R_31,
    R_32, R_33, R_34, R_35, R_36, R_37, R_38, R_39,
    R_40, R_41, R_42, R_43, R_44, R_45, R_46, R_47,
    R_48, R_49, R_50, R_51, R_52, R_53, R_54, R_55,
    R_56, R_57, R_58, R_59, R_60, R_61, R_62, R_63,
    // scratch regs
    SR_0, SR_1, SR_2, SR_3, SR_4, SR_5, SR_6, SR_7,
    SR_8, SR_9, SR_10, SR_11, SR_12, SR_13, SR_14, SR_15
);

reg_class pred_reg(
    PR_0, PR_1, PR_2, PR_3, PR_4, PR_5, PR_6, PR_7,
    PR_8, PR_9, PR_10, PR_11, PR_12, PR_13, PR_14, PR_15,
    PR_16, PR_17, PR_18, PR_19, PR_20, PR_21, PR_22, PR_23,
    PR_24, PR_25, PR_26, PR_27, PR_28, PR_29, PR_30, PR_31
);




// Empty register class.
reg_class no_reg();

%}

//----------SOURCE BLOCK-------------------------------------------------------
// This is a block of C++ code which provides values, functions, and
// definitions necessary in the rest of the architecture description
source %{
#define   RELOC_IMM64    Assembler::imm_operand
#define   RELOC_DISP32   Assembler::disp32_operand

#define __ _masm.

// !!!!! Special hack to get all types of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.
int MachCallStaticJavaNode::ret_addr_offset()
{
  return -1;
}

int MachCallDynamicJavaNode::ret_addr_offset()
{
  return -1;
}

int MachCallRuntimeNode::ret_addr_offset() {
  return -1;
}

// Indicate if the safepoint node needs the polling page as an input,
// it does if the polling page is more than disp32 away.
bool SafePointNode::needs_polling_address_input()
{
  return Assembler::is_polling_page_far();
}

//
// Compute padding required for nodes which need alignment
//

//=============================================================================
const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;

int Compile::ConstantTable::calculate_table_base_offset() const {
  return 0;  // absolute addressing, no offset
}

bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {
  ShouldNotReachHere();
}

void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  // Empty encoding
}

uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  return 0;
}

#ifndef PRODUCT
void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  st->print("# MachConstantBaseNode (empty encoding)");
}
#endif


//=============================================================================
#ifndef PRODUCT
void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  Compile* C = ra_->C;

  int framesize = C->frame_size_in_bytes();
  int bangsize = C->bang_size_in_bytes();
  //assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove wordSize for return addr which is already pushed.
  framesize -= wordSize;

  if (C->need_stack_bang(bangsize)) {
    framesize -= wordSize;
    st->print("# stack bang (%d bytes)", bangsize);
    st->print("\n\t");
    st->print("pushq   rbp\t# Save rbp");
    if (PreserveFramePointer) {
        st->print("\n\t");
        st->print("movq    rbp, rsp\t# Save the caller's SP into rbp");
    }
    if (framesize) {
      st->print("\n\t");
      st->print("subq    rsp, #%d\t# Create frame",framesize);
    }
  } else {
    st->print("subq    rsp, #%d\t# Create frame",framesize);
    st->print("\n\t");
    framesize -= wordSize;
    st->print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
    if (PreserveFramePointer) {
      st->print("\n\t");
      st->print("movq    rbp, rsp\t# Save the caller's SP into rbp");
      if (framesize > 0) {
        st->print("\n\t");
        st->print("addq    rbp, #%d", framesize);
      }
    }
  }

  if (VerifyStackAtCalls) {
    st->print("\n\t");
    framesize -= wordSize;
    st->print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
#ifdef ASSERT
    st->print("\n\t");
    st->print("# stack alignment check");
#endif
  }
  st->cr();
}
#endif

void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {

}

uint MachPrologNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachPrologNode::reloc() const
{
  return 0; // a large enough number
}

//=============================================================================
#ifndef PRODUCT
void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  Compile* C = ra_->C;
  if (C->max_vector_size() > 16) {
    st->print("vzeroupper");
    st->cr(); st->print("\t");
  }

  int framesize = C->frame_size_in_bytes();
  //assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove word for return adr already pushed
  // and RBP
  framesize -= 2*wordSize;

  if (framesize) {
    st->print_cr("addq    rsp, %d\t# Destroy frame", framesize);
    st->print("\t");
  }

  st->print_cr("popq   rbp");
  if (do_polling() && C->is_method_compilation()) {
    st->print("\t");
    if (Assembler::is_polling_page_far()) {
      st->print_cr("movq   rscratch1, #polling_page_address\n\t"
                   "testl  rax, [rscratch1]\t"
                   "# Safepoint: poll for GC");
    } else {
      st->print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
                   "# Safepoint: poll for GC");
    }
  }
}
#endif

void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
}

uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachEpilogNode::reloc() const
{
  return 2; // a large enough number
}

const Pipeline* MachEpilogNode::pipeline() const
{
  return MachNode::pipeline_class();
}

int MachEpilogNode::safepoint_offset() const
{
  return 0;
}

//=============================================================================

enum RC {
  rc_bad,
  rc_int,
  rc_float,
  rc_stack
};

uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
                                       PhaseRegAlloc* ra_,
                                       bool do_size,
                                       outputStream* st) const {
	return 0;
}

#ifndef PRODUCT
void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
  implementation(NULL, ra_, false, st);
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  implementation(&cbuf, ra_, false, NULL);
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  return 0;
}

//=============================================================================
#ifndef PRODUCT
void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_reg_first(this);
  st->print("leaq    %s, [rsp + #%d]\t# box lock",
            Matcher::regName[reg], offset);
}
#endif

void BoxLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {}

uint BoxLockNode::size(PhaseRegAlloc *ra_) const
{
  return 8;
}

//=============================================================================
#ifndef PRODUCT
void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  if (UseCompressedClassPointers) {
    st->print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
    st->print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
    st->print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
  } else {
    st->print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
                 "# Inline cache check");
  }
  st->print_cr("\tjne     SharedRuntime::_ic_miss_stub");
  st->print_cr("\tnop\t# nops to align entry point");
}
#endif

void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {}

uint MachUEPNode::size(PhaseRegAlloc* ra_) const {}


//=============================================================================

int Matcher::regnum_to_fpu_offset(int regnum)
{
  return 0; // The FP registers are in the second chunk
}

// This is UltraSparc specific, true just means we have fast l2f conversion
const bool Matcher::convL2FSupported(void) {
  return true;
}

// Is this branch offset short enough that a short branch can be used?
//
// NOTE: If the platform does not provide any short branch variants, then
//       this method should return false for offset 0.
bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
  return false;
}

const bool Matcher::isSimpleConstant64(jlong value) {
  // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
  //return value == (int) value;  // Cf. storeImmL and immL32.

  // Probably always true, even if a temp register is required.
  return true;
}

// The ecx parameter to rep stosq for the ClearArray node is in words.
const bool Matcher::init_array_count_is_in_bytes = false;

// Threshold size for cleararray.
const int Matcher::init_array_short_size = 8 * BytesPerLong;

// No additional cost for CMOVL.
const int Matcher::long_cmove_cost() { return 1; }

// No CMOVF/CMOVD with SSE2
const int Matcher::float_cmove_cost() { return 1; }

// Does the CPU require late expand (see block.cpp for description of late expand)?
const bool Matcher::require_postalloc_expand = false;

// Should the Matcher clone shifts on addressing modes, expecting them
// to be subsumed into complex addressing expressions or compute them
// into registers?  True for Intel but false for most RISCs
const bool Matcher::clone_shift_expressions = false;

// Do we need to mask the count passed to shift instructions or does
// the cpu only look at the lower 5/6 bits anyway?
const bool Matcher::need_masked_shift_count = false;

bool Matcher::narrow_oop_use_complex_address() {
  assert(UseCompressedOops, "only for compressed oops code");
  // Complex addressing is not supported;
  return false;
}

bool Matcher::narrow_klass_use_complex_address() {
  assert(UseCompressedClassPointers, "only for compressed klass code");
  // Complex addressing is not supported;
  return false;
}

// Is it better to copy float constants, or load them directly from
// memory?  Intel can load a float constant from a direct address,
// requiring no extra registers.  Most RISCs will have to materialize
// an address into a register first, so they would do better to copy
// the constant from stack.
const bool Matcher::rematerialize_float_constants = false; // XXX

// If CPU can load and store mis-aligned doubles directly then no
// fixup is needed.  Else we split the double into 2 integer pieces
// and move it piece-by-piece.  Only happens when passing doubles into
// C code as the Java calling convention forces doubles to be aligned.
const bool Matcher::misaligned_doubles_ok = true;

// No-op on amd64
void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}

// Advertise here if the CPU requires explicit rounding operations to
// implement the UseStrictFP mode.
const bool Matcher::strict_fp_requires_explicit_rounding = false;

// Are floats conerted to double when stored to stack during deoptimization?
// On x64 it is stored without convertion so we can use normal access.
bool Matcher::float_in_double() { return false; }

// Do ints take an entire long register or just half?
const bool Matcher::int_in_long = true;

// Return whether or not this register is ever used as an argument.
// This function is used on startup to build the trampoline stubs in
// generateOptoStub.  Registers not mentioned will be killed by the VM
// call in the trampoline, and arguments in those registers not be
// available to the callee.
bool Matcher::can_be_java_arg(int reg)
{
  return reg < 8;
}

bool Matcher::is_spillable_arg(int reg)
{
  return true;
}

bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
  // In 64 bit mode a code which use multiply when
  // devisor is constant is faster than hardware
  // DIV instruction (it uses MulHiL).
  return false;
}

// Register for DIVI projection of divmodI
RegMask Matcher::divI_proj_mask() {
  return NO_REG_mask();
}

// Register for MODI projection of divmodI
RegMask Matcher::modI_proj_mask() {
  return NO_REG_mask();
}

// Register for DIVL projection of divmodL
RegMask Matcher::divL_proj_mask() {
  return NO_REG_mask();
}

// Register for MODL projection of divmodL
RegMask Matcher::modL_proj_mask() {
  return NO_REG_mask();
}

// Register for saving SP into on method handle invokes. Not used on x86_64.
const RegMask Matcher::method_handle_invoke_SP_save_mask() {
    return NO_REG_mask();
}

%}

//----------ENCODING BLOCK-----------------------------------------------------
// This block specifies the encoding classes used by the compiler to
// output byte streams.  Encoding classes are parameterized macros
// used by Machine Instruction Nodes in order to generate the bit
// encoding of the instruction.  Operands specify their base encoding
// interface with the interface keyword.  There are currently
// supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &
// COND_INTER.  REG_INTER causes an operand to generate a function
// which returns its register number when queried.  CONST_INTER causes
// an operand to generate a function which returns the value of the
// constant when queried.  MEMORY_INTER causes an operand to generate
// four functions which return the Base Register, the Index Register,
// the Scale Value, and the Offset Value of the operand when queried.
// COND_INTER causes an operand to generate six functions which return
// the encoding code (ie - encoding bits for the instruction)
// associated with each basic boolean condition for a conditional
// instruction.
//
// Instructions specify two basic values for encoding.  Again, a
// function is available to check if the constant displacement is an
// oop. They use the ins_encode keyword to specify their encoding
// classes (which must be a sequence of enc_class names, and their
// parameters, specified in the encoding block), and they use the
// opcode keyword to specify, in order, their primary, secondary, and
// tertiary opcode.  Only the opcode sections which a particular
// instruction needs for encoding need to be specified.
//encode %{
  // Build emit functions for each basic byte or larger field in the
  // intel encoding scheme (opcode, rm, sib, immediate), and call them
  // from C++ code in the enc_class source block.  Emit functions will
  // live in the main source block for now.  In future, we can
  // generalize this by adding a syntax that specifies the sizes of
  // fields in an order, so that the adlc can build the emit functions
  // automagically

//%}



//----------FRAME--------------------------------------------------------------
// Definition of frame structure and management information.
//
//  S T A C K   L A Y O U T    Allocators stack-slot number
//                             |   (to get allocators register number
//  G  Owned by    |        |  v    add OptoReg::stack0())
//  r   CALLER     |        |
//  o     |        +--------+      pad to even-align allocators stack-slot
//  w     V        |  pad0  |        numbers; owned by CALLER
//  t   -----------+--------+----> Matcher::_in_arg_limit, unaligned
//  h     ^        |   in   |  5
//        |        |  args  |  4   Holes in incoming args owned by SELF
//  |     |        |        |  3
//  |     |        +--------+
//  V     |        | old out|      Empty on Intel, window on Sparc
//        |    old |preserve|      Must be even aligned.
//        |     SP-+--------+----> Matcher::_old_SP, even aligned
//        |        |   in   |  3   area for Intel ret address
//     Owned by    |preserve|      Empty on Sparc.
//       SELF      +--------+
//        |        |  pad2  |  2   pad to align old SP
//        |        +--------+  1
//        |        | locks  |  0
//        |        +--------+----> OptoReg::stack0(), even aligned
//        |        |  pad1  | 11   pad to align new SP
//        |        +--------+
//        |        |        | 10
//        |        | spills |  9   spills
//        V        |        |  8   (pad0 slot for callee)
//      -----------+--------+----> Matcher::_out_arg_limit, unaligned
//        ^        |  out   |  7
//        |        |  args  |  6   Holes in outgoing args owned by CALLEE
//     Owned by    +--------+
//      CALLEE     | new out|  6   Empty on Intel, window on Sparc
//        |    new |preserve|      Must be even-aligned.
//        |     SP-+--------+----> Matcher::_new_SP, even aligned
//        |        |        |
//
// Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
//         known from SELF's arguments and the Java calling convention.
//         Region 6-7 is determined per call site.
// Note 2: If the calling convention leaves holes in the incoming argument
//         area, those holes are owned by SELF.  Holes in the outgoing area
//         are owned by the CALLEE.  Holes should not be nessecary in the
//         incoming area, as the Java calling convention is completely under
//         the control of the AD file.  Doubles can be sorted and packed to
//         avoid holes.  Holes in the outgoing arguments may be nessecary for
//         varargs C calling conventions.
// Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
//         even aligned with pad0 as needed.
//         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
//         region 6-11 is even aligned; it may be padded out more so that
//         the region from SP to FP meets the minimum stack alignment.
// Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
//         alignment.  Region 11, pad1, may be dynamically extended so that
//         SP meets the minimum alignment.

frame
%{
  // What direction does stack grow in (assumed to be same for C & Java)
  stack_direction(TOWARDS_LOW);

  // These three registers define part of the calling convention
  // between compiled code and the interpreter.
  inline_cache_reg(GR_7);                // Inline Cache Register
  interpreter_method_oop_reg(GR_1);      // Method Oop Register when
                                        // calling interpreter

  // Optional: name the operand used by cisc-spilling to access
  // [stack_pointer + offset]
  cisc_spilling_operand_name(indOffset32);

  // Number of stack slots consumed by locking an object
  sync_stack_slots(2);

  // Compiled code's Frame Pointer
  frame_pointer(GR_8);

  // Interpreter stores its frame pointer in a register which is
  // stored to the stack by I2CAdaptors.
  // I2CAdaptors convert from interpreted java to compiled java.
  interpreter_frame_pointer(GR_8);

  // Stack alignment requirement
  stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -> 16 bytes)

  // Number of stack slots between incoming argument block and the start of
  // a new frame.  The PROLOG must add this many slots to the stack.  The
  // EPILOG must remove this many slots.  amd64 needs two slots for
  // return address.
  in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);

  // Number of outgoing stack slots killed above the out_preserve_stack_slots
  // for calls to C.  Supports the var-args backing area for register parms.
  varargs_C_out_slots_killed(0);

  // The after-PROLOG location of the return address.  Location of
  // return address specifies a type (REG or STACK) and a number
  // representing the register number (i.e. - use a register name) or
  // stack slot.
  // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
  // Otherwise, it is above the locks and verification slot and alignment word
  return_addr(STACK - 2 + round_to(0, 2));

  // Body of function which returns an integer array locating
  // arguments either in registers or in stack slots.  Passed an array
  // of ideal registers called "sig" and a "length" count.  Stack-slot
  // offsets are based on outgoing arguments, i.e. a CALLER setting up
  // arguments for a CALLEE.  Incoming stack arguments are
  // automatically biased by the preserve_stack_slots field above.

  calling_convention
  %{
    // No difference between ingoing/outgoing just pass false
    SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);
  %}

  c_calling_convention
  %{
    // This is obviously always outgoing
    (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
  %}

  // Location of compiled Java return values.  Same as C for now.
  return_value
  %{
    return OptoReg::Name(R_0_num);
  %}
%}

//----------ATTRIBUTES---------------------------------------------------------
//----------Operand Attributes-------------------------------------------------
op_attrib op_cost(0);        // Required cost attribute

//----------Instruction Attributes---------------------------------------------
ins_attrib ins_cost(100);       // Required cost attribute
ins_attrib ins_size(8);         // Required size attribute (in bits)
ins_attrib ins_short_branch(0); // Required flag: is this instruction
                                // a non-matching short branch variant
                                // of some long branch?
ins_attrib ins_alignment(1);    // Required alignment attribute (must
                                // be a power of 2) specifies the
                                // alignment that some part of the
                                // instruction (not necessarily the
                                // start) requires.  If > 1, a
                                // compute_padding() function must be
                                // provided for the instruction

//----------OPERANDS-----------------------------------------------------------
// Operand definitions must precede instruction definitions for correct parsing
// in the ADLC because operands constitute user defined types which are used in
// instruction definitions.

//----------Simple Operands----------------------------------------------------
// Immediate Operands
// Integer Immediate
// Constant for test vs zero
operand immI0()
%{
  predicate(n->get_int() == 0);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for increment
operand immI1()
%{
  predicate(n->get_int() == 1);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for decrement
operand immI_M1()
%{
  predicate(n->get_int() == -1);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Valid scale values for addressing modes
operand immI2()
%{
  predicate(0 <= n->get_int() && (n->get_int() <= 3));
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_16()
%{
  predicate(n->get_int() == 16);
  match(ConI);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_24()
%{
  predicate(n->get_int() == 24);
  match(ConI);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_32()
%{
  predicate( n->get_int() == 32 );
  match(ConI);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_64()
%{
  predicate( n->get_int() == 64 );
  match(ConI);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI8()
%{
  predicate((-0x80 <= n->get_int()) && (n->get_int() < 0x80));
  match(ConI);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI16()
%{
  predicate((-32768 <= n->get_int()) && (n->get_int() <= 32767));
  match(ConI);

  op_cost(2);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for byte-wide masking
operand immI_255()
%{
  predicate(n->get_int() == 255);
  match(ConI);

  op_cost(2);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for short-wide masking
operand immI_65535()
%{
  predicate(n->get_int() == 65535);
  match(ConI);

  op_cost(3);
  format %{ %}
  interface(CONST_INTER);
%}

// Int Immediate non-negative
operand immU31()
%{
  predicate(n->get_int() >= 0);
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for long shifts


// Constant for long shifts

// Constants for increment

operand immI()
%{
  match(ConI);

  op_cost(3);
  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate

// NULL Pointer Immediate
operand immP0()
%{
  predicate(n->get_ptr() == 0);
  match(ConP);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate
operand immN() %{
  match(ConN);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

operand immNKlass() %{
  match(ConNKlass);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// NULL Pointer Immediate
operand immN0() %{
  predicate(n->get_narrowcon() == 0);
  match(ConN);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immP31()
%{
  predicate(n->as_Type()->type()->reloc() == relocInfo::none
            && (n->get_ptr() >> 31) == 0);
  match(ConP);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immP()
%{
  match(ConP);

  op_cost(6);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate

// Long Immediate 8-bit
operand immL8()
%{
  predicate(-0x80L <= n->get_long() && n->get_long() < 0x80L);
  match(ConL);

  op_cost(2);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate 32-bit unsigned
operand immUL32()
%{
  predicate(n->get_long() == (unsigned int) (n->get_long()));
  match(ConL);

  op_cost(6);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate 32-bit signed
operand immL32()
%{
  predicate(n->get_long() == (int) (n->get_long()));
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate zero
operand immL0()
%{
  predicate(n->get_long() == 0L);
  match(ConL);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for increment
operand immL1()
%{
  predicate(n->get_long() == 1);
  match(ConL);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for decrement
operand immL_M1()
%{
  predicate(n->get_long() == -1);
  match(ConL);

  op_cost(1);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate: the value 10
operand immL10()
%{
  predicate(n->get_long() == 10);
  match(ConL);

  op_cost(2);
  format %{ %}
  interface(CONST_INTER);
%}

// Long immediate from 0 to 127.
// Used for a shorter form of long mul by 10.
operand immL_127()
%{
  predicate(0 <= n->get_long() && n->get_long() < 0x80);
  match(ConL);

  op_cost(3);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate: low 32-bit mask
operand immL_32bits()
%{
  predicate(n->get_long() == 0xFFFFFFFFL);
  match(ConL);
  op_cost(3);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for byte-wide masking
operand immL_255()
%{
  predicate(n->get_long() == 255);
  match(ConL);

  op_cost(3);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for short-wide masking
operand immL_65535()
%{
  predicate(n->get_long() == 65535);
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}


operand immL()
%{
  match(ConL);

  op_cost(6);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate zero
operand immF0()
%{
  predicate(jint_cast(n->getf()) == 0);
  match(ConF);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate one
operand immF1()
%{
  predicate(jint_cast(n->getf()) == 1.0f);
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate
operand immF()
%{
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate zero
operand immD0()
%{
  predicate(jlong_cast(n->getd()) == 0);
  match(ConD);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immD1()
%{
  predicate(jlong_cast(n->getd()) == 1.0);
  match(ConD);

  op_cost(6);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate
operand immD()
%{
  match(ConD);

  op_cost(6);
  format %{ %}
  interface(CONST_INTER);
%}

// Immediates for special shifts (sign extend)

// Register Operands
// Integer Register
operand regI()
%{
  constraint(ALLOC_IN_RC(int_reg));
  match(RegI);
  op_cost(7);
  format %{ %}
  interface(REG_INTER);
%}

operand regL()
%{
  constraint(ALLOC_IN_RC(long_reg));
  match(RegL);
  op_cost(7);
  format %{ %}
  interface(REG_INTER);
%}

operand regN() %{
  constraint(ALLOC_IN_RC(int_reg));
  match(RegN);
  op_cost(7);
  format %{ %}
  interface(REG_INTER);
%}

operand regP()
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(RegP);
  op_cost(7);
  format %{ %}
  interface(REG_INTER);
%}

operand regF()
%{
  constraint(ALLOC_IN_RC(float_reg));
  match(RegF);
  op_cost(7);
  format %{ %}
  interface(REG_INTER);
%}

operand regD()
%{
  constraint(ALLOC_IN_RC(double_reg));
  match(RegD);
  op_cost(7);
  format %{ %}
  interface(REG_INTER);
%}

operand regPred()
%{
  constraint(ALLOC_IN_RC(pred_reg));
  match(RegFlags);

  format %{ %}
  interface(REG_INTER);
%}

// Flags register, used as output of FLOATING POINT compare instructions
operand regPredU()
%{
  constraint(ALLOC_IN_RC(pred_reg));
  match(RegFlags);

  format %{ %}
  interface(REG_INTER);
%}

// Vectors
operand vecS() %{
  constraint(ALLOC_IN_RC(long_reg));
  match(VecS);

  format %{ %}
  interface(REG_INTER);
%}

operand vecD() %{
  constraint(ALLOC_IN_RC(int_reg));
  match(VecD);

  format %{ %}
  interface(REG_INTER);
%}

//----------Memory Operands----------------------------------------------------
// Direct Memory Operand
//operand direct(immP addr)
//%{
//  match(addr);
//
//  format %{ "[$addr]" %}
//  interface(MEMORY_INTER) %{
//    base(0x0);
//    disp($addr);
//  %}
//%}

// Indirect Memory Operand
operand indirect(regP reg)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(reg);

  op_cost(5);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    disp(0x0);
  %}
%}


// Indirect Memory Plus Long Offset Operand
operand indOffset(regP reg, immL off)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg off);

  format %{ "[$reg + $off]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    disp($off);
  %}
%}

// Indirect Memory Plus Index Register Plus Offset Operand
operand indIndex(regP breg, regL dreg)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP breg dreg);

  op_cost(10);
  format %{"[$breg + $dreg]" %}
  interface(MEMORY_INTER) %{
    base($breg);
    index($dreg);
  %}
%}

//----------Conditional Branch Operands----------------------------------------
// Comparison Op  - This is the operation of the comparison, and is limited to
//                  the following set of codes:
//                  L (<), LE (<=), G (>), GE (>=), E (==), NE (!=)
//
// Other attributes of the comparison, such as unsignedness, are specified
// by the comparison instruction that sets a condition code flags register.
// That result is represented by a flags operand whose subtype is appropriate
// to the unsignedness (etc.) of the comparison.
//
// Later, the instruction which matches both the Comparison Op (a Bool) and
// the flags (produced by the Cmp) specifies the coding of the comparison op
// by matching a specific subtype of Bool operand below, such as cmpOpU.

// Comparision Code
operand cmpOp() %{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal        (0x0, "eq");
    not_equal    (0x1, "ne");
    less         (0x2, "lt");
    less_equal   (0x3, "le");
    greater      (0x4, "gt");
    greater_equal(0x5, "ge");
    overflow     (0xa, "o");
    no_overflow  (0xb, "no");
  %}
%}

operand cmpOpU() %{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal        (0x0, "eq");
    not_equal    (0x1, "ne");
    less         (0x6, "ult");
    less_equal   (0x7, "ule");
    greater      (0x8, "ugt");
    greater_equal(0x9, "uge");
    overflow     (0xa, "o");
    no_overflow  (0xb, "no");
  %}
%}

//----------OPERAND CLASSES----------------------------------------------------
// Operand Classes are groups of operands that are used as to simplify
// instruction definitions by not requiring the AD writer to specify separate
// instructions for every form of operand when the instruction accepts
// multiple operand types with the same basic encoding and format.  The classic
// case of this is memory operands.

opclass memory(/*direct, */indirect, indOffset, indIndex);

//----------PIPELINE-----------------------------------------------------------
// Rules which define the behavior of the target architectures pipeline.
pipeline %{

//----------ATTRIBUTES---------------------------------------------------------
attributes %{
  variable_size_instructions;        // Fixed size instructions
  max_instructions_per_bundle = 23;  // Up to 3 instructions per bundle
  instruction_unit_size = 4;         // An instruction is 1 bytes long
  instruction_fetch_unit_size = 16;  // The processor fetches one line
  instruction_fetch_units = 1;       // of 16 bytes

  // List of nop instructions
  nops( MachNop );
%}

//----------PIPELINE DESCRIPTION-----------------------------------------------
// Pipeline Description specifies the stages in the machine's pipeline

// Generic P2/P3 pipeline

//----------PIPELINE CLASSES---------------------------------------------------
// Pipeline Classes describe the stages in which input and output are
// referenced by the hardware pipeline.

// Naming convention: ialu or fpu
// Then: _reg
// Then: _reg if there is a 2nd register
// Then: _long if it's a pair of instructions implementing a long
// Then: _fat if it requires the big decoder
//   Or: _mem if it requires the big decoder and a memory unit.

// Integer ALU reg operation
resources( ALU0, ALU1, ALU2, ALU3, ALU4, ALU5 );

// The real do-nothing guy
pipe_class empty()
%{
    instruction_count(0);
%}

// Define the class for the Nop node
define
%{
   MachNop = empty;
%}

%}

//----------INSTRUCTIONS-------------------------------------------------------
//
// match      -- States which machine-independent subtree may be replaced
//               by this instruction.
// ins_cost   -- The estimated cost of this instruction is used by instruction
//               selection to identify a minimum cost tree of machine
//               instructions that matches a tree of machine-independent
//               instructions.
// format     -- A string providing the disassembly for this instruction.
//               The value of an instruction's operand may be inserted
//               by referring to it with a '$' prefix.
// opcode     -- Three instruction opcodes may be provided.  These are referred
//               to within an encode class as $primary, $secondary, and $tertiary
//               rrspectively.  The primary opcode is commonly used to
//               indicate the type of machine instruction, while secondary
//               and tertiary are often used for prefix options or addressing
//               modes.
// ins_encode -- A list of encode classes with parameters. The encode class
//               name must have been defined in an 'enc_class' specification
//               in the encode section of the architecture description.


//----------Load/Store/Move Instructions---------------------------------------
//----------Load Instructions--------------------------------------------------

// Load Byte (8 bit signed)
instruct loadB(regI dst, memory mem)
%{
  match(Set dst (LoadB mem));

  ins_cost(1);
  format %{ "ldb  $mem, $dst\t# byte" %}

  ins_encode(  /*empty*/ );

  ins_pipe(empty);
%}


// Load Unsigned Byte (8 bit UNsigned)
instruct loadUB(regI dst, memory mem)
%{
  match(Set dst (LoadUB mem));

  ins_cost(1);
  format %{ "ldb  $mem, $dst\t# byte" %}

  ins_encode(  /*empty*/ );

  ins_pipe(empty);
%}

// Load Short (16 bit signed)
instruct loadS(regI dst, memory mem)
%{
  match(Set dst (LoadS mem));

  ins_cost(1);
  format %{ "ldh  $mem, $dst\t# short" %}

  ins_encode(  /*empty*/ );

  ins_pipe(empty);
%}

// Load Unsigned Short/Char (16 bit UNsigned)
instruct loadUS(regI dst, memory mem)
%{
  match(Set dst (LoadUS mem));

  ins_cost(1);
  format %{ "ldh  $mem, $dst\t# char" %}

  ins_encode(  /*empty*/ );

  ins_pipe(empty);
%}

// Load Integer
instruct loadI(regI dst, memory mem)
%{
  match(Set dst (LoadI mem));

  ins_cost(1);
  format %{ "ldw  $mem, $dst\t# integer" %}

  ins_encode(  /*empty*/ );

  ins_pipe(empty);
%}

// Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
instruct loadI2UB(regI dst, memory mem, immI_255 mask) %{
  match(Set dst (AndI (LoadI mem) mask));

  ins_cost(1);
  format %{ "ldb  $mem, $dst\t# byte" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
instruct loadI2US(regI dst, memory mem, immI_65535 mask) %{
  match(Set dst (AndI (LoadI mem) mask));

  ins_cost(1);
  format %{ "ldh  $mem, $dst\t# char" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Load Long
instruct loadL(regL dst, memory mem)
%{
  match(Set dst (LoadL mem));

  ins_cost(1);
  format %{ "ldd  $mem, $dst\t# long" %}

  ins_encode(  /*empty*/ );

  ins_pipe(empty); // XXX
%}

// Load Range
instruct loadRange(regI dst, memory mem)
%{
  match(Set dst (LoadRange mem));

  ins_cost(1); // XXX
  format %{ "ldw  $mem, $dst\t# range" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Load Pointer
instruct loadTLABtop(regP dst, memory mem)
%{
  predicate(n->in(MemNode::Address)->is_AddP()
        && (n->in(MemNode::Address)->in(2)->Opcode() == Op_ThreadLocal)
        && (n->in(MemNode::Address)->in(3)->Opcode() == Op_ConL)
        && (((ConLNode*)(n->in(MemNode::Address)->in(3)))->get_long() == in_bytes(JavaThread::tlab_top_offset())));
  match(Set dst (LoadP mem));

  ins_cost(1); // XXX
  format %{ "mov    dg14, $dst\t#TLAB top" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadTLABend(regP dst, memory mem)
%{
  predicate(n->in(MemNode::Address)->is_AddP()
        && (n->in(MemNode::Address)->in(2)->Opcode() == Op_ThreadLocal)
        && (n->in(MemNode::Address)->in(3)->Opcode() == Op_ConL)
        && (((ConLNode*)(n->in(MemNode::Address)->in(3)))->get_long() == in_bytes(JavaThread::tlab_end_offset())));
  match(Set dst (LoadP mem));

  ins_cost(1); // XXX
  format %{ "mov    dg15, $dst\t#TLAB end" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Load Pointer
instruct loadP(regP dst, memory mem)
%{
  match(Set dst (LoadP mem));

  ins_cost(3); // XXX
  format %{ "ldd  $mem, $dst\t# ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Load Compressed Pointer
instruct loadN(regN dst, memory mem)
%{
   match(Set dst (LoadN mem));

   ins_cost(1); // XXX
   format %{ "ldw    $mem, $dst\t# compressed ptr" %}
   ins_encode();
   ins_pipe(empty); // XXX
%}

// Load Klass Pointer
instruct loadKlass(regP dst, memory mem)
%{
  match(Set dst (LoadKlass mem));

  ins_cost(1); // XXX
  format %{ "ldd  $mem, $dst\t# class" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Load Narrow Klass Pointer
instruct loadNKlass(regN dst, memory mem)
%{
  match(Set dst (LoadNKlass mem));

  ins_cost(1); // XXX
  format %{ "ldw  $mem, $dst\t# narrow class" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Load Float
instruct loadF(regF dst, memory mem)
%{
  match(Set dst (LoadF mem));

  ins_cost(1); // XXX
  format %{ "ldw  $mem, $dst\t# float" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadD(regD dst, memory mem)
%{
  match(Set dst (LoadD mem));

  ins_cost(1); // XXX
  format %{ "ldd  $mem, $dst\t# double" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}


instruct loadConI(regI dst, immI src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "mov    $src, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadConI1(regI dst, immI1 src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "mov    $src, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadConI0(regI dst, immI0 src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "movs    $src, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConL(regL dst, immL src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movd    $src, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConL0(regL dst, immL0 src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movd    $src, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConUL32(regL dst, immUL32 src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movs    $src, $dst\t# long (unsigned 32-bit)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConL32(regL dst, immL32 src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movd    $src, $dst\t# long (32-bit)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConP(regP dst, immP con)
%{
  match(Set dst con);

  ins_cost(60);
  format %{ "movd    $con, $dst\t# ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadConN(regN dst, immN con)
%{
  match(Set dst con);

  ins_cost(60);
  format %{ "movs    $con, $dst\t# compressed ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadConNKlass(regN dst, immNKlass src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movs    $src, $dst\t# compressed klass ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConP0(regP dst, immP0 src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movd    $src, $dst\t# ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConN0(regN dst, immN0 con)
%{
  match(Set dst con);

  ins_cost(60);
  format %{ "movs    $con, $dst\t# zero narrow ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct loadConF(regF dst, immF con)
%{
  match(Set dst con);
  ins_cost(60);
  format %{ "movs   $con, $dst\t# load from constant table: float=$con" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConF0(regF dst, immF0 src)
%{
  match(Set dst src);
  ins_cost(60);

  format %{ "movs   $src, $dst\t# float 0.0" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Use the same format since predicate() can not be used here.
instruct loadConD(regD dst, immD con)
%{
  match(Set dst con);
  ins_cost(60);
  format %{ "movd   $con, $dst\t# load from constant table: double=$con" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct loadConD0(regD dst, immD0 src)
%{
  match(Set dst src);
  ins_cost(60);

  format %{ "movd   $src, $dst\t# double 0.0" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Prefetch instructions for allocation.

instruct prefetchrNTA( memory mem ) %{
  predicate(ReadPrefetchInstr==0);
  match(PrefetchRead mem);
  ins_cost(125);

  format %{ "PREFETCHNTA $mem\t# Prefetch into non-temporal cache for read" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct prefetchrT0( memory mem ) %{
  predicate(ReadPrefetchInstr==1);
  match(PrefetchRead mem);
  ins_cost(125);

  format %{ "PREFETCHT0 $mem\t# prefetch into L1 and L2 caches for read" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct prefetchrT2( memory mem ) %{
  predicate(ReadPrefetchInstr==2);
  match(PrefetchRead mem);
  ins_cost(125);

  format %{ "PREFETCHT2 $mem\t# prefetch into L2 caches for read" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct prefetchwNTA( memory mem ) %{
  match(PrefetchWrite mem);
  ins_cost(125);

  format %{ "PREFETCHNTA $mem\t# Prefetch to non-temporal cache for write" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Prefetch instructions for allocation.

instruct prefetchAlloc( memory mem ) %{
  predicate(AllocatePrefetchInstr==3);
  match(PrefetchAllocation mem);
  ins_cost(125);

  format %{ "PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct prefetchAllocNTA( memory mem ) %{
  predicate(AllocatePrefetchInstr==0);
  match(PrefetchAllocation mem);
  ins_cost(125);

  format %{ "PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct prefetchAllocT0( memory mem ) %{
  predicate(AllocatePrefetchInstr==1);
  match(PrefetchAllocation mem);
  ins_cost(125);

  format %{ "PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct prefetchAllocT2( memory mem ) %{
  predicate(AllocatePrefetchInstr==2);
  match(PrefetchAllocation mem);
  ins_cost(125);

  format %{ "PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


//----------Store Instructions-------------------------------------------------

// Store Byte
instruct storeB(memory mem, regI src)
%{
  match(Set mem (StoreB mem src));

  ins_cost(1); // XXX
  format %{ "stb    $src, $mem\t# byte" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Char/Short
instruct storeC(memory mem, regI src)
%{
  match(Set mem (StoreC mem src));

  ins_cost(1); // XXX
  format %{ "sth    $src, $mem\t# char/short" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Integer
instruct storeI(memory mem, regI src)
%{
  match(Set mem (StoreI mem src));

  ins_cost(1); // XXX
  format %{ "stw    $src, $mem\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Long
instruct storeL(memory mem, regL src)
%{
  match(Set mem (StoreL mem src));

  ins_cost(1); // XXX
  format %{ "std    $src, $mem\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct storeTLABtop(memory mem, regP src)
%{
  predicate(n->in(MemNode::Address)->is_AddP()
        && (n->in(MemNode::Address)->in(2)->Opcode() == Op_ThreadLocal)
        && (n->in(MemNode::Address)->in(3)->Opcode() == Op_ConL)
        && (((ConLNode*)(n->in(MemNode::Address)->in(3)))->get_long() == in_bytes(JavaThread::tlab_top_offset())));
  match(Set mem (StoreP mem src));

  ins_cost(1); // XXX
  format %{ "mov    $src, dg14\t#TLAB top" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct storeTLABend(memory mem, regP src)
%{
  predicate(n->in(MemNode::Address)->is_AddP()
        && (n->in(MemNode::Address)->in(2)->Opcode() == Op_ThreadLocal)
        && (n->in(MemNode::Address)->in(3)->Opcode() == Op_ConL)
        && (((ConLNode*)(n->in(MemNode::Address)->in(3)))->get_long() == in_bytes(JavaThread::tlab_end_offset())));
  match(Set mem (StoreP mem src));

  ins_cost(1); // XXX
  format %{ "mov    $src, dg15\t#TLAB end" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Store Pointer
instruct storeP(memory mem, regP src)
%{
  match(Set mem (StoreP mem src));

  ins_cost(4); // XXX
  format %{ "std    $src, $mem\t# ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct storeImmP0(memory mem, immP0 zero)
%{
  match(Set mem (StoreP mem zero));

  ins_cost(1); // XXX
  format %{ "std    r_zero, $mem\t# ptr (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Compressed Pointer
instruct storeN(memory mem, regN src)
%{
  match(Set mem (StoreN mem src));

  ins_cost(1); // XXX
  format %{ "stw    $mem, $src\t# compressed ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct storeNKlass(memory mem, regN src)
%{
  match(Set mem (StoreNKlass mem src));

  ins_cost(1); // XXX
  format %{ "stw    $mem, $src\t# compressed klass ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct storeImmN0(memory mem, immN0 zero)
%{
  match(Set mem (StoreN mem zero));

  ins_cost(1); // XXX
  format %{ "stw    $mem, R12\t# compressed ptr (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Integer Immediate
instruct storeImmI0(memory mem, immI0 zero)
%{
  match(Set mem (StoreI mem zero));

  ins_cost(1); // XXX
  format %{ "stw    r_zero, $mem\t# int (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Long Immediate
instruct storeImmL0(memory mem, immL0 zero)
%{
  match(Set mem (StoreL mem zero));

  ins_cost(1); // XXX
  format %{ "std    r_zero, $mem\t# long (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Short/Char Immediate
instruct storeImmC0(memory mem, immI0 zero)
%{
  match(Set mem (StoreC mem zero));

  ins_cost(1); // XXX
  format %{ "sth    r_zero, $mem\t# short/char (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Byte Immediate
instruct storeImmB0(memory mem, immI0 zero)
%{
  match(Set mem (StoreB mem zero));

  ins_cost(1); // XXX
  format %{ "stb    r_zero, $mem\t# short/char (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store CMS card-mark Immediate
instruct storeImmCM0(memory mem, immI0 src)
%{
  match(Set mem (StoreCM mem src));

  ins_cost(1); // XXX
  format %{ "stb    $src, $mem\t# CMS card-mark byte 0" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store condition card-mark Immediate
instruct storeImmCondCM0(memory mem, immI0 zero)
%{
  match(Set mem (StoreCME2K mem zero));

  ins_cost(1); // XXX
  format %{ "ldb    $mem, regX\t# load existing value\n\t"
            "cmpesb regX, 0, predX\t# calc predicate\n\t"
            "stb    $zero, $mem ? ~predX\t# store 0 if clean" %}
  ins_encode();
  ins_pipe(empty);
%}

// Store Float
instruct storeF(memory mem, regF src)
%{
  match(Set mem (StoreF mem src));

  ins_cost(1); // XXX
  format %{ "stw    $src, $mem\t# float" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Store immediate Float value (it is faster than store from XMM register)
instruct storeImmF0(memory mem, immF0 zero)
%{
  match(Set mem (StoreF mem zero));

  ins_cost(1); // XXX
  format %{ "stw    r_zero, $mem\t# float 0. (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Store Double
instruct storeD(memory mem, regD src)
%{
  match(Set mem (StoreD mem src));

  ins_cost(1); // XXX
  format %{ "std    $src, $mem\t# double" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct storeImmD0(memory mem, immD0 zero)
%{
  match(Set mem (StoreD mem zero));

  ins_cost(1); // XXX
  format %{ "std    r_zero, $mem\t# double 0. (R12_heapbase==0)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//----------BSWAP Instructions-------------------------------------------------

instruct bits_reverse_int(regI dst, regI src) %{
  match(Set dst (ReverseI src));

  format %{ "bitrev  $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct bits_reverse_long(regL dst, regL src) %{
  match(Set dst (ReverseL src));

  format %{ "bitrev  $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

/*
instruct bytes_reverse_int(regI dst, regI src) %{
  match(Set dst (ReverseBytesI src));

  format %{ "bitrev  $src, $dst" %}
  ins_encode(  );
  ins_pipe(empty);
%}

instruct bytes_reverse_long(regL dst, regL src) %{
  match(Set dst (ReverseBytesL src));

  format %{ "bitrev  $src, $dst" %}
  ins_encode(  );
  ins_pipe(empty);
%}

instruct bytes_reverse_unsigned_short(regI dst, regI src) %{
  match(Set dst (ReverseBytesUS src));

  format %{ "bitrev  $src, $dst\n\t"
            "shr    $dst, 16, $dst\n\t" %}
  ins_encode(  );
  ins_pipe(empty);
%}

instruct bytes_reverse_short(regI dst, regI src) %{
  match(Set dst (ReverseBytesS src));

  format %{ "bitrev  $src, $dst\n\t"
            "sar     $dst, 16, $dst\n\t" %}
  ins_encode(  );
  ins_pipe(empty);
%}
*/

//---------- Zeros Count Instructions ------------------------------------------

instruct countLeadingZerosI(regI dst, regI src) %{
  match(Set dst (CountLeadingZerosI src));

  format %{ "lzcnt  $src, $dst\t# count leading zeros (int)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


instruct countLeadingZerosL(regI dst, regL src) %{
  match(Set dst (CountLeadingZerosL src));

  format %{ "lzcnt  $src, $dst\t# count leading zeros (long)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct countTrailingZerosI(regI dst, regI src) %{
  match(Set dst (CountTrailingZerosI src));

  format %{ "bitrev    $src, $dst\t# count trailing zeros #1 (int)"
            "tzcntl    $dst, $dst\t# count trailing zeros #2 (int)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct countTrailingZerosL(regI dst, regL src) %{
  match(Set dst (CountTrailingZerosL src));

  format %{ "bitrev    $src, $dst\t# count trailing zeros #1 (long)"
            "tzcntl    $dst, $dst\t# count trailing zeros #2 (long)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//---------- Population Count Instructions -------------------------------------

instruct popCountI(regI dst, regI src) %{
  match(Set dst (PopCountI src));

  format %{ "popcnt  $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Note: Long.bitCount(long) returns an int.
instruct popCountL(regI dst, regL src) %{
  match(Set dst (PopCountL src));

  format %{ "popcnt  $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//----------MemBar Instructions-----------------------------------------------
// Memory barrier flavors

instruct membar_acquire()
%{
  match(MemBarAcquire);
  ins_cost(1);

  format %{ "mov reg, rempty" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_loadfence()
%{
  match(LoadFence);
  ins_cost(1);

  format %{ "wait LD_C" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_acquire_lock()
%{
  match(MemBarAcquireLock);
  ins_cost(0);

  format %{ "MEMBAR acquire LOCK" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_release()
%{
  match(MemBarRelease);
  ins_cost(0);

  format %{ "wait ST_C | LD_C | SAS | SAL" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_storefence()
%{
  match(StoreFence);
  ins_cost(0);

  format %{ "wait ST_C" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_release_lock()
%{
  match(MemBarReleaseLock);
  ins_cost(0);

  format %{ "MEMBAR release LOCK" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_volatile() %{
  match(MemBarVolatile);
  ins_cost(1);

  format %{ "wait ST_C" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct unnecessary_membar_volatile()
%{
  match(MemBarVolatile);
  predicate(Matcher::post_store_load_barrier(n));
  ins_cost(1);

  format %{ "wait ST_C" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct membar_storestore() %{
  match(MemBarStoreStore);
  ins_cost(1);

  format %{ "wait ST_C | SAS" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//----------Move Instructions--------------------------------------------------

instruct castX2P(regP dst, regL src)
%{
  match(Set dst (CastX2P src));

  format %{ "movd    $src, $dst\t# long->ptr" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct castP2X(regL dst, regP src)
%{
  match(Set dst (CastP2X src));

  format %{ "movd    $src, $dst\t# ptr -> long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Convert oop into int for vectors alignment masking
instruct convP2I(regI dst, regP src)
%{
  match(Set dst (ConvL2I (CastP2X src)));

  format %{ "movs    $src, $dst\t# ptr -> int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Convert compressed oop into int for vectors alignment masking
// in case of 32bit oops (heap < 4Gb).
instruct convN2I(regI dst, regN src)
%{
  predicate(Universe::narrow_oop_shift() == 0);
  match(Set dst (ConvL2I (CastP2X (DecodeN src))));

  format %{ "movs    $dst, $src\t# compressed ptr -> int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Convert oop pointer into compressed form
instruct encodeHeapOop(regN dst, regP src) %{
  predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);
  match(Set dst (EncodeP src));
  format %{ "encode_heap_oop $dst,$src" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct encodeHeapOop_not_null(regN dst, regP src) %{
  predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);
  match(Set dst (EncodeP src));
  format %{ "encode_heap_oop_not_null $dst,$src" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct decodeHeapOop(regP dst, regN src) %{
  predicate(n->bottom_type()->is_ptr()->ptr() != TypePtr::NotNull &&
            n->bottom_type()->is_ptr()->ptr() != TypePtr::Constant);
  match(Set dst (DecodeN src));
  format %{ "decode_heap_oop $dst,$src" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct decodeHeapOop_not_null(regP dst, regN src) %{
  predicate(n->bottom_type()->is_ptr()->ptr() == TypePtr::NotNull ||
            n->bottom_type()->is_ptr()->ptr() == TypePtr::Constant);
  match(Set dst (DecodeN src));
  format %{ "decode_heap_oop_not_null $dst,$src" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct encodeKlass_not_null(regN dst, regP src) %{
  match(Set dst (EncodePKlass src));
  format %{ "encode_klass_not_null $dst,$src" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct decodeKlass_not_null(regP dst, regN src) %{
  match(Set dst (DecodeNKlass src));
  format %{ "decode_klass_not_null $dst,$src" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Jump
// dummy instruction for generating temp registers

instruct jumpXtnd(regL switch_val) %{
  match(Jump switch_val);

  format %{ "switch $switch_val" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


//----------Conditional Move---------------------------------------------------

instruct mergeI_reg_reg(cmpOp cmp, regPred pr, regI src1, regI src2, regI dst)
%{
  match(Set dst (CMoveI (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merges $src1, $src2, $dst ? $pr $cmp # int" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeUI_reg_reg(cmpOpU cmp, regPredU pr, regI src1, regI src2, regI dst)
%{
  match(Set dst (CMoveI (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merges $src1, $src2, $dst ? $pr $cmp # int" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeL_reg_reg(cmpOp cmp, regPred pr, regL src1, regL src2, regL dst)
%{
  match(Set dst (CMoveL (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merged $src1, $src2, $dst ? $pr $cmp # long" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeUL_reg_reg(cmpOpU cmp, regPredU pr, regL src1, regL src2, regL dst)
%{
  match(Set dst (CMoveL (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merged $src1, $src2, $dst ? $pr $cmp # long" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeF_reg_reg(cmpOp cmp, regPred pr, regF src1, regF src2, regF dst)
%{
  match(Set dst (CMoveF (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merges $src1, $src2, $dst ? $pr $cmp # float" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeUF_reg_reg(cmpOpU cmp, regPredU pr, regF src1, regF src2, regF dst)
%{
  match(Set dst (CMoveF (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merges $src1, $src2, $dst ? $pr $cmp # float" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeD_reg_reg(cmpOp cmp, regPred pr, regD src1, regD src2, regD dst)
%{
  match(Set dst (CMoveD (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merged $src1, $src2, $dst ? $pr $cmp # double" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeUD_reg_reg(cmpOpU cmp, regPredU pr, regD src1, regD src2, regD dst)
%{
  match(Set dst (CMoveD (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merged $src1, $src2, $dst ? $pr $cmp # double" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeP_reg_reg(cmpOp cmp, regPred pr, regP src1, regP src2, regP dst)
%{
  match(Set dst (CMoveP (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merged $src1, $src2, $dst ? $pr $cmp # long" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeUP_reg_reg(cmpOpU cmp, regPredU pr, regP src1, regP src2, regP dst)
%{
  match(Set dst (CMoveP (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merged $src1, $src2, $dst ? $pr $cmp # long" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeN_reg_reg(cmpOp cmp, regPred pr, regN src1, regN src2, regN dst)
%{
  match(Set dst (CMoveN (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merges $src1, $src2, $dst ? $pr $cmp # float" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct mergeUN_reg_reg(cmpOpU cmp, regPredU pr, regN src1, regN src2, regN dst)
%{
  match(Set dst (CMoveN (Binary cmp pr) (Binary src1 src2)));
  effect(DEF dst, USE pr, USE src1, USE src2);
  ins_cost(40);
  format %{ "merges $src1, $src2, $dst ? $pr $cmp # float" %}
  ins_encode();
  ins_pipe(empty);
%}

//----------Arithmetic Instructions--------------------------------------------
//----------Addition Instructions----------------------------------------------

instruct addI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (AddI src1 src2));

  format %{ "adds    $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct addI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (AddI src1 src2));

  format %{ "adds    $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct subI_rReg_I1(regI dst, regI src1, immI_M1 src2)
%{
  match(Set dst (AddI src1 src2));

  format %{ "subs    $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct addL_rReg(regL dst, regL src1, regL src2)
%{
  match(Set dst (AddL src1 src2));

  format %{ "addd    $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct addL_rReg_imm(regL dst, regL src1, immL src2)
%{
  match(Set dst (AddL src1 src2));

  format %{ "addd    $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct subL_rReg_L1(regL dst, regL src1, immL_M1 src2)
%{
  match(Set dst (AddI src1 src2));

  format %{ "subd    src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct addP_rReg(regP dst, regP base, regL offset)
%{
  match(Set dst (AddP base offset));

  format %{ "addd    $base, $offset, $dst\t# ptr" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct addP_rReg_imm(regP dst, regP base, immL offset)
%{
  match(Set dst (AddP base offset));

  format %{ "addd    $base, $offset, $dst\t# ptr" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct checkCastPP(regP dst, regP src)
%{
  match(Set dst (CheckCastPP src));


  format %{ "mov $src $dst" %}
  ins_encode(/* empty encoding */);
  ins_pipe(empty);
%}

instruct castPP(regP dst)
%{
  match(Set dst (CastPP dst));

  size(0);
  format %{ "# castPP of $dst" %}
  ins_encode(/* empty encoding */);
  ins_pipe(empty);
%}

instruct castII(regI dst)
%{
  match(Set dst (CastII dst));

  size(0);
  format %{ "# castII of $dst" %}
  ins_encode(/* empty encoding */);
  ins_cost(0);
  ins_pipe(empty);
%}

// LoadP-locked same as a regular LoadP when used with compare-swap
instruct loadPLocked(regP dst, memory mem)
%{
  match(Set dst (LoadPLocked mem));

  ins_cost(1); // XXX
  format %{ "ldd    $mem, $dst\t# ptr locked" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Conditional-store of the updated heap-top.
// Used during allocation of the shared heap.
// Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.

instruct storePConditional(regPred pr, memory mem, regP oldval, regP newval)
%{
  match(Set pr (StorePConditional mem (Binary oldval newval)));
  effect(DEF pr, USE oldval, USE newval);

  format %{ "cmpxchg $mem, $oldval, $newval $pr\t# (ptr) " %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Conditional-store of an int value.
// ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
instruct storeIConditional(regPred pr, memory mem, regI oldval, regI newval)
%{
  match(Set pr (StoreIConditional mem (Binary oldval newval)));
  effect(DEF pr, USE oldval, USE newval);

  format %{ "cmpxchg $mem, $oldval, $newval $pr\t# If rax == $mem then store $newval into $mem" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Conditional-store of a long value.
// ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
instruct storeLConditional(regPred pr, memory mem, regL oldval, regL newval)
%{
  match(Set pr (StoreLConditional mem (Binary oldval newval)));
  effect(DEF pr, USE oldval, USE newval);

  format %{ "cmpxchg $mem, $oldval, $newval $pr\t# If rax == $mem then store $newval into $mem" %}
  ins_encode(   );
  ins_pipe(empty);
%}


// XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
instruct compareAndSwapP(regI res, memory mem_ptr, regP oldval, regP newval)
%{
  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));

  format %{ "cmpxchg $mem_ptr, $oldval, $newval, $res\t# " %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct compareAndSwapN(regI res, memory mem_ptr, regN oldval, regN newval)
%{
  match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));

  format %{ "cmpxchg $mem_ptr, $oldval compressed oop, $newval compressed oop, $res\t# " %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct compareAndSwapL(regI res, memory mem_ptr, regL oldval, regL newval)
%{
  match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));

  format %{ "cmpxchg $mem_ptr, $oldval, $newval, $res\t# " %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct compareAndSwapI(regI res, memory mem_ptr, regI oldval, regI newval)
%{
  match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));

  format %{ "cmpxchg $mem_ptr, $oldval, $newval, $res\t# " %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}


instruct xaddI( memory mem, regI newval, regI dst)
%{
  match(Set dst (GetAndAddI mem newval));
  format %{ "XADDS  [$mem], $newval, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct xaddL( memory mem, regL newval, regL dst)
%{
  match(Set dst (GetAndAddL mem newval));
  format %{ "XADDD  [$mem], $newval, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct xchgI( memory mem, regI newval, regI dst)
%{
  match(Set dst (GetAndSetI mem newval));
  format %{ "XCHGS  [$mem], $newval, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct xchgL( memory mem, regL newval, regL dst)
%{
  match(Set dst (GetAndSetL mem newval));
  format %{ "XCHGD  [$mem], $newval, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct xchgP( memory mem, regP newval, regP dst)
%{
  match(Set dst (GetAndSetP mem newval));
  format %{ "XCHGD  [$mem], $newval, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct xchgN( memory mem, regN newval, regN dst)
%{
  match(Set dst (GetAndSetP mem newval));
  format %{ "XCHGS  [$mem], $newval, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

//----------Subtraction Instructions-------------------------------------------

// Integer Subtraction Instructions
instruct subI_rReg(regI src1, regI src2, regI dst)
%{
  match(Set dst (SubI src1 src2));

  format %{ "subs    $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct subI_rReg_imm0(immI0 src1, regI src2, regI dst)
%{
  match(Set dst (SubI src1 src2));

  format %{ "subs    0, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


instruct subI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (SubI src1 src2));

  format %{ "subs    $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct subL_rReg(regL dst, regL src1, regL src2)
%{
  match(Set dst (SubL src1 src2));

  format %{ "subd    $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct subL_rReg_imm0(regL dst, immL0 src1, regL src2)
%{
  match(Set dst (SubL src1 src2));

  format %{ "subd    0, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct subL_rReg_imm(regL dst, regL src1, immL src2)
%{
  match(Set dst (SubL src1 src2));

  format %{ "subd    $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Subtract from a pointer
// XXX hmpf???
instruct subP_rReg(regP dst, regI src1, regP src2, immI0 zero)
%{
  match(Set dst (AddP src2 (SubI zero src1)));

  format %{ "subd    $src1, $src2, $dst\t# ptr - int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//----------Multiplication/Division Instructions-------------------------------
// Integer Multiplication Instructions
// Multiply Register

instruct mulI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (MulI src1 src2));

  ins_cost(1);
  format %{ "muls   $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct mulI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (MulI src1 src2));

  ins_cost(1);
  format %{ "muls   $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct mulX_reg_reg(regI src1, regI src2, regL dst)
%{
  match(Set dst (MulL (ConvI2L src1) (ConvI2L src2)));

  ins_cost(1);
  format %{ "smulx   $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct mulL_rReg(regL dst, regL src1, regL src2)
%{
  match(Set dst (MulL src1 src2));

  ins_cost(1);
  format %{ "muld   $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct mulL_rReg_imm(regL dst, regL src1, immL src2)
%{
  match(Set dst (MulL src1 src2));

  ins_cost(1);
  format %{ "muld   $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct divI_rReg(regI src1, regI src2, regI dst)
%{
  match(Set dst (DivI src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivs   $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct divI_rReg_imm(regI src1, immI src2, regI dst)
%{
  match(Set dst (DivI src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivs   $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct divL_rReg(regL src1, regL src2, regL dst)
%{
  match(Set dst (DivL src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivd   $src1, $src2, $dst\t# long" %}
  ins_encode(/*empty*/);
  ins_pipe(empty);
%}

instruct divL_rReg_imm(regL src1, immL src2, regL dst)
%{
  match(Set dst (DivL src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivd   $src1, $src2, $dst\t# long" %}
  ins_encode(/*empty*/);
  ins_pipe(empty);
%}

instruct modI_rReg(regI src1, regI src2, regI dst)
%{
  match(Set dst (ModI src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivs   $src1, $src2, $dst\t# ModI(1)"
            "muls    $dst, $src2, $dst\t#  ModI(2)"
            "subs    $src1, $dst, $dst\t#  ModI(3)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct modI_rReg_imm(regI src1, immI src2, regI dst)
%{
  match(Set dst (ModI src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivs   $src1, $src2, $dst\t# ModI(1)"
            "muls    $dst, $src2, $dst\t#  ModI(2)"
            "subs    $src1, $dst, $dst\t#  ModI(3)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct modL_rReg(regL src1, regL src2, regL dst)
%{
  match(Set dst (ModL src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivd   $src1, $src2, $dst\t# ModI(1)"
            "muld    $dst, $src2, $dst\t#  ModI(2)"
            "subd    $src1, $dst, $dst\t#  ModI(3)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct modL_rReg_imm(regL src1, immL src2, regL dst)
%{
  match(Set dst (ModL src1 src2));

  ins_cost(1); // XXX
  format %{ "sdivd   $src1, $src2, $dst\t# ModI(1)"
            "muld    $dst, $src2, $dst\t#  ModI(2)"
            "subd    $src1, $dst, $dst\t#  ModI(3)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Integer Shift Instructions
// Shift Left by imm
instruct salI_rReg_imm(regI src, immI shift, regI dst)
%{
  match(Set dst (LShiftI src shift));

  format %{ "shls    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Shift Left by variable
instruct salI_rReg_CL(regI src, regI shift, regI dst)
%{
  match(Set dst (LShiftI src shift));

  format %{ "shls    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Arithmetic shift right by imm
instruct sarI_rReg_imm(regI src, immI shift, regI dst)
%{
  match(Set dst (RShiftI src shift));

  format %{ "sars    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Arithmetic Shift Right by variable
instruct sarI_rReg_CL(regI src, regI shift, regI dst)
%{
  match(Set dst (RShiftI src shift));

  format %{ "sarl    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Logical shift right by imm
instruct shrI_rReg_imm(regI src, immI shift, regI dst)
%{
  match(Set dst (URShiftI src shift));

  format %{ "shrl    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Logical Shift Right by variable
instruct shrI_rReg_CL(regI src, regI shift, regI dst)
%{
  match(Set dst (URShiftI src shift));

  format %{ "shrl    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Long Shift Instructions
// Shift Left by imm
instruct salL_rReg_imm(regL src, immI shift, regL dst)
%{
  match(Set dst (LShiftL src shift));

  format %{ "shld    $src, $shift, $dst" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Long Shift Instructions
// Shift Left by imm
instruct salL_index_rReg_imm(regI src, immI shift, regL dst)
%{
  predicate(n->in(1)->as_Type()->type()->is_long()->_lo >= 0);
  match(Set dst (LShiftL (ConvI2L src) shift));

  format %{ "shld    $src, $shift, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

// Shift Left by variable
instruct salL_rReg_CL(regL src, regI shift, regL dst)
%{
  match(Set dst (LShiftL src shift));

  format %{ "shld    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Arithmetic shift right by imm
instruct sarL_rReg_imm(regL src, immI shift, regL dst)
%{
  match(Set dst (RShiftL src shift));

  format %{ "sard    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Arithmetic Shift Right by variable
instruct sarL_rReg_CL(regL src, regI shift, regL dst)
%{
  match(Set dst (RShiftL src shift));

  format %{ "sard    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Logical shift right by imm
instruct shrL_rReg_imm(regL src, immI shift, regL dst)
%{
  match(Set dst (URShiftL src shift));

  format %{ "shrd    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Logical Shift Right by variable
instruct shrL_rReg_CL(regL src, regI shift, regL dst)
%{
  match(Set dst (URShiftL src shift));

  format %{ "shrd    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
// This idiom is used by the compiler for the i2b bytecode.
instruct i2b(regI dst, regI src, immI_24 twentyfour)
%{
  match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));

  format %{ "sxt  BS, $src, $dst\t# i2b" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
// This idiom is used by the compiler the i2s bytecode.
instruct i2s(regI dst, regI src, immI_16 sixteen)
%{
  match(Set dst (RShiftI (LShiftI src sixteen) sixteen));

  format %{ "sxt  HS, $src, $dst\t# i2s" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by one
instruct rolI_rReg_i1(regI dst, regI src, immI1 lshift, immI_M1 rshift)
%{
  match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));

  format %{ "scls    $src, $lshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by 8-bit immediate
instruct rolI_rReg_i8(regI dst, regI src, immI8 lshift, immI8 rshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x1f));
  match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));

  format %{ "scls    $src, $lshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// WTF doesn't work, fix it later
// Rotate Left by imm
instruct rolI_rReg_imm_C0(regI dst, regI src, immI shift, immI0 zero)
%{
  match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI zero shift))));

  format %{ "scls    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Rotate Left by variable
instruct rolI_rReg_Var_C0(regI dst, regI src, regI shift, immI0 zero)
%{
  match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI zero shift))));

  format %{ "scls    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by imm
instruct rolI_rReg_imm_C32(regI dst, regI src, immI shift, immI_32 c32)
%{
  match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI c32 shift))));

  format %{ "scls    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by variable
instruct rolI_rReg_Var_C32(regI dst, regI src, regI shift, immI_32 c32)
%{
  match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI c32 shift))));

  ins_cost(1);
  format %{ "scls    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Rotate Right by one
instruct rorI_rReg_i1(regI dst, regI src, immI1 rshift, immI_M1 lshift)
%{
  match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));

  format %{ "scrs    $src, $rshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by 8-bit immediate
instruct rorI_rReg_i8(regI dst, regI src, immI8 rshift, immI8 lshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x1f));
  match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));

  format %{ "scrs    $src, $rshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by imm
instruct rorI_rReg_imm_C0(regI dst, regI src, immI shift, immI0 zero)
%{
  match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI zero shift))));

  format %{ "scrs    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by variable
instruct rorI_rReg_Var_C0(regI dst, regI src, regI shift, immI0 zero)
%{
  match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI zero shift))));

  format %{ "scrs    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by imm
instruct rorI_rReg_imm_C32(regI dst, regI src, immI shift, immI_32 c32)
%{
  match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI c32 shift))));

  format %{ "scrs    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by variable
instruct rorI_rReg_Var_C32(regI dst, regI src, regI shift, immI_32 c32)
%{
  match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI c32 shift))));

  format %{ "scrs    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// for long rotate

// Rotate Left by one
instruct rolL_rReg_i1(regL dst, regL src, immI1 lshift, immI_M1 rshift)
%{
  match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));

  format %{ "scld    $src, $lshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by 8-bit immediate
instruct rolL_rReg_i8(regL dst, regL src, immI8 lshift, immI8 rshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));
  match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));

  format %{ "scld    $src, $lshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by imm
instruct rolL_rReg_imm_C0(regL dst, regL src, immI shift, immI0 zero)
%{
  match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI zero shift))));

  format %{ "scld    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Rotate Left by variable
instruct rolL_rReg_Var_C0(regL dst, regL src, regI shift, immI0 zero)
%{
  match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI zero shift))));

  format %{ "scld    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by imm
instruct rolL_rReg_imm_C64(regL dst, regL src, immI shift, immI_64 c64)
%{
  match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI c64 shift))));

  format %{ "scld    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Left by variable
instruct rolL_rReg_Var_C64(regL dst, regL src, regI shift, immI_64 c64)
%{
  match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI c64 shift))));

  format %{ "scld    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Rotate Right by one
instruct rorL_rReg_i1(regL dst, regL src, immI1 rshift, immI_M1 lshift)
%{
  match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));

  format %{ "scrd    $src, $rshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by 8-bit immediate
instruct rorL_rReg_i8(regL dst, regL src, immI8 rshift, immI8 lshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));
  match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));

  format %{ "scrd    $src, $rshift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by imm
instruct rorL_rReg_imm_C0(regL dst, regL src, immI shift, immI0 zero)
%{
  match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI zero shift))));

  format %{ "scrd    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by variable
instruct rorL_rReg_Var_C0(regL dst, regL src, regI shift, immI0 zero)
%{
  match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI zero shift))));

  format %{ "scrd    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by imm
instruct rorL_rReg_imm_C64(regL dst, regL src, immI shift, immI_64 c64)
%{
  match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI c64 shift))));

  format %{ "scrd    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rotate Right by variable
instruct rorL_rReg_Var_C64(regL dst, regL src, regI shift, immI_64 c64)
%{
  match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI c64 shift))));

  format %{ "scrd    $src, $shift, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Logical Instructions

// Integer Logical Instructions

// And Instructions
// And Register with Register
instruct andI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (AndI src1 src2));

  format %{ "ands    $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// And Register with Immediate
instruct andI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (AndI src1 src2));

  format %{ "ands  $src1, $src2, $dst\t# int & imm" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// And Register with Immediate 255 and promote to long
instruct andI2L_rReg_imm255(regL dst, regI src, immI_255 mask)
%{
  match(Set dst (ConvI2L (AndI src mask)));

  format %{ "sxt  BZ, $src, $dst\t# int & 0xFF -> long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// And Register with Immediate 65535 and promote to long
instruct andI2L_rReg_imm65535(regL dst, regI src, immI_65535 mask)
%{
  match(Set dst (ConvI2L (AndI src mask)));

  ins_cost(1);
  format %{ "sxt  HZ, $src, $dst\t# int & 0xFFFF -> long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// And Register with Immediate 65535 and promote to long
instruct andI_rReg_imm65535(regI dst, regI src, immI_65535 mask)
%{
  match(Set dst (AndI src mask));

  ins_cost(1);
  format %{ "sxt  HZ, $src, $dst\t# int & 0xFFFF -> long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// BMI1 instructions

// src1 & ~src2
instruct andnI_rReg_rReg_rReg(regI dst, regI src1, regI src2, immI_M1 minus_1) %{
  match(Set dst (AndI src1 (XorI src2 minus_1)));

  format %{ "andns  $src1, $src2, $dst" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// src1 | ~src2
instruct ornI_rReg_rReg_rReg(regI dst, regI src1, regI src2, immI_M1 minus_1) %{
  match(Set dst (OrI src1 (XorI src2 minus_1)));

  format %{ "orns  $src1, $src2, $dst" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// src1 ^ ~src2
instruct xornI_rReg_rReg_rReg(regI dst, regI src1, regI src2, immI_M1 minus_1) %{
  match(Set dst (XorI src1 (XorI src2 minus_1)));

  format %{ "xorns  $src1, $src2, $dst" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// TODO: implement getfs/getfd

// Or Instructions
// Or Register with Register
instruct orI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (OrI src1 src2));

  format %{ "ors     $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Or Register with Immediate
instruct orI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (OrI src1 src2));

  format %{ "ors     $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Xor Instructions
// Xor Register with Register
instruct xorI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (XorI src1 src2));

  format %{ "xors     $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Xor Register with Immediate
instruct xorI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (XorI src1 src2));

  format %{ "xors     $src1, $src2, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Long Logical Instructions

// And Instructions
// And Register with Register
instruct andL_rReg(regL dst, regL src1, regL src2)
%{
  match(Set dst (AndL src1 src2));

  format %{ "andd    $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// And Register with Immediate
instruct andL_rReg_imm(regL dst, regL src1, immL src2)
%{
  match(Set dst (AndL src1 src2));

  format %{ "andd    $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// BMI1 instructions
// src1 & ~src2
instruct andnL_rReg_rReg_rReg(regL dst, regL src1, regL src2, immL_M1 minus_1) %{
  match(Set dst (AndL src1 (XorL src2 minus_1)));

  format %{ "andnd  $src1, $src2, $dst" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// src1 | ~src2
instruct ornL_rReg_rReg_rReg(regL dst, regL src1, regL src2, immL_M1 minus_1) %{
  match(Set dst (OrL src1 (XorL src2 minus_1)));

  format %{ "ornd  $src1, $src2, $dst" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// src1 ^ ~src2
instruct xornL_rReg_rReg_rReg(regL dst, regL src1, regL src2, immL_M1 minus_1) %{
  match(Set dst (XorL src1 (XorL src2 minus_1)));

  format %{ "xornd  $src1, $src2, $dst" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Or Instructions
// Or Register with Register
instruct orL_rReg(regL dst, regL src1, regL src2)
%{
  match(Set dst (OrL src1 src2));

  format %{ "ord     $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Or Register with Immediate
instruct orL_rReg_imm(regL dst, regL src1, immL src2)
%{
  match(Set dst (OrL src1 src2));

  format %{ "ord     $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Xor Instructions
// Xor Register with Register
instruct xorL_rReg(regL dst, regL src1, regL src2)
%{
  match(Set dst (XorL src1 src2));

  format %{ "xord     $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Xor Register with Immediate
instruct xorL_rReg_imm(regL dst, regL src1, immL src2)
%{
  match(Set dst (XorL src1 src2));

  format %{ "xord     $src1, $src2, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// Convert Int to Boolean
instruct convI2B(regI dst, regI src)
%{
  match(Set dst (Conv2B src));

  format %{ "cmpesb  $src, 0, predX\t# compare\n\t"
            "merges  0, 1, $dst ? predX\n\t make bool" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

// Convert Pointer to Boolean
instruct convP2B(regI dst, regP src)
%{
  match(Set dst (Conv2B src));

  format %{ "cmpedb  $src, 0, predX\t# compare\n\t"
            "merges  0, 1, $dst ? predX\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}

instruct cmpLTMask(regI dst, regI p, regI q)
%{
  match(Set dst (CmpLTMask p q));

  ins_cost(1);
  format %{ "cmplsb  $p, $q, predX\t# compare\n\t"
            "merges  0, -1, $dst ? predX\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct cmpLTMask0(regI dst, regI src, immI0 zero)
%{
  match(Set dst (CmpLTMask src zero));

  ins_cost(1);
  format %{ "sarl    $src, 31, $dst\t# cmpLTMask0" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

/* Better to save a register than avoid a branch */
instruct cadd_cmpLTMask(regI dst, regI p, regI q, regI y)
%{
  match(Set dst (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
  ins_cost(1);

  format %{ "cmplesb   $q, $p, predX\t\n# cadd_cmpLTMask\n\t"
            "adds      $p, $y, tmp\t\n#"
            "merges    tmp, $p, $dst ? predX\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

/* Better to save a register than avoid a branch */
instruct and_cmpLTMask(regI dst, regI p, regI q, regI y)
%{
  match(Set dst (AndI (CmpLTMask p q) y));

  ins_cost(1);

  format %{ "cmplsb   $p, $q, predX\t# and_cmpLTMask\n\t"
            "merges   0, $y, $dst ? predX\t#" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


//---------- FP Instructions------------------------------------------------

// Compare into -1,0,1
instruct cmpF3_reg(regI dst, regF src1, regF src2)
%{
  match(Set dst (CmpF3 src1 src2));

  ins_cost(1);
  format %{ "fcmpesb $src1, $src2, pred_EQ\n\t"
            "fcmpltsb $src1, $src2, pred_LT\n\t"
            "fcmpuodsb $src1, $src2, pred_UOD\n\t"
            "merges 1, 0, $dst ? pred_EQ\n\t"
            "merges $dst, -1, $dst ? pred_LT\n\t"
            "merges $dst, -1, $dst ? pred_UOD\n" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Compare into -1,0,1
instruct cmpF3_imm(regI dst, regF src, immF con) %{
  match(Set dst (CmpF3 src con));

  ins_cost(1);
  format %{ "fcmpesb $src, $con, pred_EQ\n\t"
            "fcmpltsb $src, $con, pred_LT\n\t"
            "fcmpuodsb $src, $con, pred_UOD\n\t"
            "merges 1, 0, $dst ? pred_EQ\n\t"
            "merges $dst, -1, $dst ? pred_LT\n\t"
            "merges $dst, -1, $dst ? pred_UOD\n" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Compare into -1,0,1
instruct cmpD3_reg(regI dst, regD src1, regD src2)
%{
  match(Set dst (CmpD3 src1 src2));

  ins_cost(1);
  format %{ "fcmpedb $src1, $src2, pred_EQ\n\t"
            "fcmpltdb $src1, $src2, pred_LT\n\t"
            "fcmpuoddb $src1, $src2, pred_UOD\n\t"
            "merges 1, 0, $dst ? pred_EQ\n\t"
            "merges $dst, -1, $dst ? pred_LT\n\t"
            "merges $dst, -1, $dst ? pred_UOD\n" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Compare into -1,0,1
instruct cmpD3_imm(regI dst, regD src, immD con) %{
  match(Set dst (CmpD3 src con));

  ins_cost(1);
  format %{ "fcmpedb $src, $con, pred_EQ\n\t"
            "fcmpltdb $src, $con, pred_LT\n\t"
            "fcmpuoddb $src, $con, pred_UOD\n\t"
            "merges 1, 0, $dst ? pred_EQ\n\t"
            "merges $dst, -1, $dst ? pred_LT\n\t"
            "merges $dst, -1, $dst ? pred_UOD\n" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// -----------Trig and Trancendental Instructions------------------------------
instruct cosD_reg(regD src, regD dst) %{
  match(Set dst (CosD src));

  format %{ "dcos   $src, $dst\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct sinD_reg(regD src, regD dst) %{
  match(Set dst (SinD src));

  format %{ "dsin   $src, $dst\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct tanD_reg(regD src, regD dst) %{
  match(Set dst (TanD src));

  format %{ "dtan   $src, $dst\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct log10D_reg(regD src, regD dst) %{
  match(Set dst (Log10D src));

  format %{ "dlog10   $src, $dst\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct logD_reg(regD src, regD dst) %{
  match(Set dst (LogD src));

  format %{ "dlog   $src, $dst\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct powD_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (PowD src1 src2));  // Raise src0 to the src1'th power

  format %{ "powD $src1 $src2 $dst\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct expD_reg(regD dst, regD src) %{
  match(Set dst (ExpD src));

  format %{ "expD   $src, $dst\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

//----------Arithmetic Conversion Instructions---------------------------------

instruct roundFloat_nop(regF dst, regF src)
%{
  match(Set dst (RoundFloat src));

  ins_cost(0);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct roundDouble_nop(regD dst, regD src)
%{
  match(Set dst (RoundDouble src));

  ins_cost(0);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convF2D_reg_reg(regD dst, regF src)
%{
  match(Set dst (ConvF2D src));

  format %{ "fstofd $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}


instruct convD2F_reg_reg(regF dst, regD src)
%{
  match(Set dst (ConvD2F src));

  format %{ "fdtofs $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty); // XXX
%}


// XXX do mem variants
instruct convF2I_reg_reg(regI dst, regF src)
%{
  match(Set dst (ConvF2I src));

  format %{ "fstoistr $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convF2L_reg_reg(regL dst, regF src)
%{
  match(Set dst (ConvF2L src));

  format %{ "fstoid $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convD2I_reg_reg(regI dst, regD src)
%{
  match(Set dst (ConvD2I src));

  format %{ "fdtoistr $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convD2L_reg_reg(regL dst, regD src)
%{
  match(Set dst (ConvD2L src));

  format %{ "fdtoid $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convI2F_reg_reg(regF dst, regI src)
%{
  match(Set dst (ConvI2F src));

  format %{ "istofs $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


instruct convI2D_reg_reg(regD dst, regI src)
%{
  match(Set dst (ConvI2D src));

  format %{ "istofd $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convL2F_reg_reg(regF dst, regL src)
%{
  match(Set dst (ConvL2F src));

  format %{ "idtofs $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convL2D_reg_reg(regD dst, regL src)
%{
  match(Set dst (ConvL2D src));

  format %{ "idtofd $src, $dst" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


instruct dummy_convI2L2I(regI dst, regI src)
%{
  match(Set dst (ConvL2I (ConvI2L src)));

  format %{ "empty" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convL2I2L(regL dst, regL src)
%{
  match(Set dst (ConvI2L (ConvL2I src)));

  format %{ "empty" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convI2L_reg_reg(regL dst, regI src)
%{
  match(Set dst (ConvI2L src));

  ins_cost(2);
  format %{ "sxt  WS, $src, $dst\t# i2l" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Zero-extend convert int to long
instruct convI2L_reg_reg_zex(regL dst, regI src, immL_32bits mask)
%{
  match(Set dst (AndL (ConvI2L src) mask));

  format %{ "sxt    WZ, $src, $dst\t# i2l zero-extend\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convI2L_z_reg_reg(regL dst, regI src)
%{
  predicate(n->as_Type()->type()->is_long()->_lo >= 0);
  match(Set dst (ConvI2L src));

  ins_cost(1);
  format %{ "sxt  WS, $src, $dst\t# i2l" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct zerox_long_reg_reg(regL dst, regL src, immL_32bits mask)
%{
  match(Set dst (AndL src mask));

  format %{ "sxt    WZ, $src, $dst\t# zero-extend long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct convL2I_reg_reg(regI dst, regL src)
%{
  match(Set dst (ConvL2I src));

  format %{ "movs    $src, $dst\t# l2i" %}

  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct MoveF2I_reg_reg(regI dst, regF src) %{
  match(Set dst (MoveF2I src));

  ins_cost(1);
  format %{ "movs    $src, $dst\t# MoveF2I" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct MoveD2L_reg_reg(regL dst, regD src) %{
  match(Set dst (MoveD2L src));

  ins_cost(1);
  format %{ "movd    $src, $dst\t# MoveD2L" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct MoveI2F_reg_reg(regF dst, regI src) %{
  match(Set dst (MoveI2F src));

  ins_cost(1);
  format %{ "movs    $src, $dst\t# MoveI2F" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct MoveL2D_reg_reg(regD dst, regL src) %{
  match(Set dst (MoveL2D src));

  ins_cost(1);
  format %{ "movd    $src, $dst\t# MoveL2D" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// =======================================================================
// fast clearing of an array
instruct clear_memory(regL cnt, regP base, Universe dummy)
%{
  match(Set dummy (ClearArray cnt base));

  format %{ "memset  ($base, 0, $cnt)\t# ClearArray:\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct string_compare(regP str1, regI cnt1, regP str2, regI cnt2, regI result)
%{
  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));

  format %{ "String Compare $str1, $cnt1, $str2, $cnt2 -> $result" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// fast search of substring with known size.
instruct string_indexof_con(regP str1, regI cnt1, regP str2, immI int_cnt2, regI result)
%{
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));

  format %{ "String IndexOf $str1, $cnt1, $str2, $int_cnt2 -> $result" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct string_indexof(regP str1, regI cnt1, regP str2, regI cnt2, regI result)
%{
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));

  format %{ "String IndexOf $str1, $cnt1, $str2, $cnt2 -> $result" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// fast string equals
instruct string_equals(regP str1, regP str2, regI cnt, regI result)
%{
  match(Set result (StrEquals (Binary str1 str2) cnt));

  format %{ "String Equals $str1,$str2,$cnt -> $result" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// fast array equals
instruct array_equals(regP ary1, regP ary2, regI result)
%{
  match(Set result (AryEq ary1 ary2));

  format %{ "Array Equals $ary1, $ary2 -> $result" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// encode char[] to byte[] in ISO_8859_1
/*
instruct encode_iso_array(regP src, regP dst, regI len, regI result) %{
  match(Set result (EncodeISOArray src (Binary dst len)));

  format %{ "Encode array $src, $dst, $len -> $result" %}
  ins_encode( );
  ins_pipe(empty);
%}
*/
//----------Overflow Math Instructions-----------------------------------------

instruct overflowAddI_rReg(regPred pr, regI op1, regI op2)
%{
  match(Set pr (OverflowAddI op1 op2));

  format %{ "subs   0, $op2, tmp\t# overflow check int\n\t"
            "cmposb $op1, $op2, $pr\t# overflow check int\n\t"
            "adds   $op1, $op2, $op1\t# do ADD" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowAddI_rReg_imm(regPred pr, regI op1, immI op2)
%{
  match(Set pr (OverflowAddI op1 op2));

  format %{ "cmposb    $op1, -$op2, $pr\t# overflow check int\n\t"
            "adds      $op1, $op2, $op1\t# do ADD"%}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowAddL_rReg(regPred pr, regL op1, regL op2)
%{
  match(Set pr (OverflowAddL op1 op2));

  format %{ "subd   0, $op2, tmp\t# overflow check long\n\t"
            "cmpodb $op1, $op2, $pr\t# overflow check long\n\t"
            "addd   $op1, $op2, $op1\t# do ADD" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowAddL_rReg_imm(regPred pr, regL op1, immL op2)
%{
  match(Set pr (OverflowAddL op1 op2));

  format %{ "cmpodb    $op1, -$op2, $pr\t# overflow check long\n\t"
             "addd     $op1, $op2, $op1\t# do ADD\n\t" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowSubI_rReg(regPred pr, regI op1, regI op2)
%{
  match(Set pr (OverflowSubI op1 op2));

  format %{ "cmposb    $op1, $op2, $pr\t# overflow check int\n\t"
            "subs      $op1, $op2, $op1\t# do SUB" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowSubI_rReg_imm(regPred pr, regI op1, immI op2)
%{
  match(Set pr (OverflowSubI op1 op2));

  format %{ "cmposb    $op1, $op2, $pr\t# overflow check int\n\t"
            "subs      $op1, $op2, $op1\t# do SUB" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowSubL_rReg(regPred pr, regL op1, regL op2)
%{
  match(Set pr (OverflowSubL op1 op2));

  format %{ "cmpodb    $op1, $op2, $pr\t# overflow check long\n\t"
            "subd      $op1, $op2, $op1\t# do SUB" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowSubL_rReg_imm(regPred pr, regL op1, immL op2)
%{
  match(Set pr (OverflowSubL op1 op2));

  format %{ "cmpodb    $op1, $op2, $pr\t# overflow check long\n\t"
            "subd      $op1, $op2, $op1\t# do SUB" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowNegI_rReg(regPred pr, immI0 zero, regI op2)
%{
  match(Set pr (OverflowSubI zero op2));

  format %{ "cmposb    0, $op2, $pr\t# overflow check int\n\t"
            "subs      0, $op2, $op2\t# do NEG" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct overflowNegL_rReg(regPred pr, immL0 zero, regL op2)
%{
  match(Set pr (OverflowSubL zero op2));

  format %{ "cmpodb    0, $op2, $pr\t# overflow check long\n\t"
            "subd      0, $op2, $op2\t# do NEG" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


//----------Control Flow Instructions------------------------------------------
// Manifest a CmpL result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpL3_reg_reg(regI dst, regL src1, regL src2)
%{
  match(Set dst (CmpL3 src1 src2));
  ins_cost(40);
  format %{ "cmpedb    $src1, $src2, pred_EQ\t# CmpL3(1)\n\t"
            "cmpldb    $src1, $src2, pred_LT\t# CmpL3(2)\n\t"
            "merges    1, 0, $dst ? pred_EQ\t# CmpL3(3)\n\t"
            "merges    $dst, -1, $dst ? pred_LT\t# CmpL3(4)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//----------Max and Min--------------------------------------------------------
// Min Instructions

instruct minI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (MinI src1 src2));

  ins_cost(40);
  format %{ "cmplesb $src1, $src2, pred_LE\t# min (pred)\n\t"
            "merges $src1, $src2, $dst ? ~pred_LE\t# min (mrg)\n\t" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct minI_rReg_imm(regI dst, regI src1, immI src2)
%{
  match(Set dst (MinI src1 src2));
  match(Set dst (MinI src2 src1));

  ins_cost(20);
  format %{ "cmplesb $src1, $src2, pred_LE\t# min (pred)\n\t"
            "merges $src1, $src2, $dst ? ~pred_LE\t# min (mrg)\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct maxI_rReg(regI dst, regI src1, regI src2)
%{
  match(Set dst (MaxI src1 src2));

  ins_cost(40);
  format %{ "cmplesb $src1, $src2, pred_LE\t# max (pred)\n\t"
            "merges $src1, $src2, $dst ? pred_LE\t# max (mrg)\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct maxI_rReg_imm(regI dst, immI src1, regI src2)
%{
  match(Set dst (MaxI src1 src2));
  match(Set dst (MaxI src2 src1));

  ins_cost(20);
  format %{ "cmplesb $src2, $src1, pred_LE\t# max (pred)\n\t"
            "merges $src2, $src1, $dst ? pred_LE\t# max (mrg)" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Condition Instructions

instruct cmpI_reg_reg(regPred pr, regI src1, regI src2)
%{
  match(Set pr (CmpI src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmps     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpI_reg_imm(regPred pr, regI src1, immI src2)
%{
  match(Set pr (CmpI src1 src2));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmps     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpandI_reg_reg(regPred pr, regI src1, regI src2, immI0 zero)
%{
  match(Set pr (CmpI (AndI src1 src2) zero));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmpands     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpandI_reg_imm(regPred pr, regI src1, immI src2, immI0 zero)
%{
  match(Set pr (CmpI (AndI src1 src2) zero));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmpands     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpU_reg_reg(regPredU pr, regI src1, regI src2)
%{
  match(Set pr (CmpU src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmps     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}


instruct cmpU_reg_imm(regPredU pr, regI src1, immI src2)
%{
  match(Set pr (CmpU src1 src2));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmps     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}


instruct cmpL_reg_reg(regPred pr, regL src1, regL src2)
%{
  match(Set pr (CmpL src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmpd     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpL_reg_imm(regPred pr, regL src1, immL src2)
%{
  match(Set pr (CmpL src1 src2));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmpd     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpandL_reg_reg(regPred pr, regL src1, regL src2, immL0 zero)
%{
  match(Set pr (CmpL (AndL src1 src2) zero));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmpandd  $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpandL_reg_imm(regPred pr, regL src1, immL src2, immL0 zero)
%{
  match(Set pr (CmpL (AndL src1 src2) zero));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmpandd  $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpF_reg_reg(regPred pr, regF src1, regF src2)
%{
  match(Set pr (CmpF src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "fcmps    $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpD_reg_reg(regPred pr, regD src1, regD src2)
%{
  match(Set pr (CmpD src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "fcmpd    $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpP_reg_reg(regPredU pr, regP src1, regP src2)
%{
  match(Set pr (CmpP src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmpd  $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpP_reg_imm(regPredU pr, regP src1, immP src2)
%{
  match(Set pr (CmpP src1 src2));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmpd  $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpN_reg_reg(regPredU pr, regN src1, regN src2)
%{
  match(Set pr (CmpN src1 src2));
  effect(DEF pr, USE src1, USE src2);

  ins_cost(1);
  format %{ "cmps     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct cmpN_reg_imm(regPredU pr, regN src1, immN src2)
%{
  match(Set pr (CmpN src1 src2));
  effect(DEF pr, USE src1);

  ins_cost(1);
  format %{ "cmps     $src1, $src2, $pr\t\n" %}
  ins_encode();
  ins_pipe(empty);
%}

// ============================================================================
// Branch Instructions

// Jump Direct - Label defines a relative address from JMP+1
instruct jmpDir(label labl)
%{
  match(Goto);
  effect(USE labl);
  ins_cost(1);
  format %{ "disp     ctprX, $labl\t\n"
            "ct       ctprX" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


instruct jmpConU(cmpOpU cop, regPredU pr, label labl)
%{
  match(If cop pr);
  effect(USE labl, USE pr);

  ins_cost(25);
  format %{ "disp     ctprX, $labl\t\n"
            "ct       ctprX ? $pr $cop" %}
  ins_encode();
  ins_pipe(empty);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpCon(cmpOp cop, regPred pr, label labl)
%{
  match(If cop pr);
  effect(USE labl, USE pr);

  ins_cost(25);
  format %{ "disp     ctprX, $labl\t\n"
            "ct       ctprX ? $pr $cop" %}
  ins_encode();
  ins_pipe(empty);
%}


instruct jmpLoopEndU(cmpOpU cop, regPredU pr, label labl) %{
  match(CountedLoopEnd cop pr);
  effect(USE labl, USE pr);

  ins_cost(25);
  format %{ "disp     ctprX, $labl\t\n"
            "ct       ctprX ? $pr $cop" %}
  ins_encode();
  ins_pipe(empty);
%}


// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpLoopEnd(cmpOp cop, regPred pr, label labl)
%{
  match(CountedLoopEnd cop pr);
  effect(USE labl, USE pr);

  ins_cost(25);
  format %{ "disp     ctprX, $labl\t\n"
            "ct       ctprX ? $pr $cop" %}
  ins_encode();
  ins_pipe(empty);
%}


instruct if_fastlock_rtm(cmpOp cmp, regP obj, regP box, label labl)
%{
  predicate(Compile::current()->use_rtm());
  match(If cmp (FastLock obj box));
  effect(USE cmp, USE obj, USE box, USE labl);

  format %{ "fastlock $obj, $box" %}
  ins_encode();
  ins_pipe(empty);
%}

// ============================================================================
// inlined locking and unlocking

instruct if_fastlock(cmpOp cmp, regP obj, regP box, label labl)
%{
  predicate(!Compile::current()->use_rtm());
  match(If cmp (FastLock obj box));
  effect(USE cmp, USE obj, USE box, USE labl);

  format %{ "fastlock $obj, $box" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct if_fastunlock(cmpOp cmp, regP obj, regP box, label labl)
%{
  match(If cmp (FastUnlock obj box));
  effect(USE cmp, USE obj, USE box, USE labl);

  format %{ "fastunlock $obj, $box" %}
  ins_encode();
  ins_pipe(empty);
%}

// ============================================================================
// The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
// superklass array for an instance of the superklass.  Set a hidden
// internal cache on a hit (cache is checked with exposed code in
// gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
// encoding ALSO sets flags.

instruct partialSubtypeCheck(regI result, regP sub, regP super)
%{
  match(Set result (PartialSubtypeCheck sub super));

  ins_cost(1);  // slightly larger than the next version
  format %{ "is_subtype $sub, $super --> $result" %}

  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

//instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
//                                     rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
//                                     immP0 zero,
//                                     rdi_RegP result)
//%{
//  match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
//  effect(KILL rcx, KILL result);
//
//  ins_cost(1000);
//  format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
//            "movl    rcx, [rdi + Array<Klass*>::length_offset_in_bytes()]\t# length to scan\n\t"
//            "addq    rdi, Array<Klass*>::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
//            "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
//            "jne,s   miss\t\t# Missed: flags nz\n\t"
//            "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
//    "miss:\t" %}
//
//  opcode(0x0); // No need to XOR RDI
//  ins_encode(enc_PartialSubtypeCheck());
//  ins_pipe(empty);
//%}

// ============================================================================
// Branch Instructions -- short offset versions
//
// These instructions are used to replace jumps of a long offset (the default
// match) with jumps of a shorter offset.  These instructions are all tagged
// with the ins_short_branch attribute, which causes the ADLC to suppress the
// match rules in general matching.  Instead, the ADLC generates a conversion
// method in the MachNode which can be used to do in-place replacement of the
// long variant with the shorter variant.  The compiler will determine if a
// branch can be taken by the is_short_branch_offset() predicate in the machine
// specific code section of the file.

// ============================================================================
// Safepoint Instructions
instruct safePoint_poll()
%{
  predicate(!Assembler::is_polling_page_far());
  match(SafePoint);

  format %{ "ldb [#poll_page + 8], g0\t# Safepoint: poll for GC" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct safePoint_poll_far(regP poll)
%{
  predicate(Assembler::is_polling_page_far());
  match(SafePoint poll);

  format %{ "ldb [#$poll], g0\t# Safepoint: poll for GC" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// ============================================================================
// Procedure Call/Return Instructions
// Call Java Static Instruction
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallStaticJavaDirect(method meth) %{
  match(CallStaticJava);

  ins_cost(1);
  format %{ "call,static " %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Call Java Dynamic Instruction
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallDynamicJavaDirect(method meth)
%{
  match(CallDynamicJava);
  effect(USE meth);

  ins_cost(1);
  format %{ "call,dynamic " %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Call Runtime Instruction
instruct CallRuntimeDirect(method meth)
%{
  match(CallRuntime);

  ins_cost(1);
  format %{ "call,runtime " %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Call runtime without safepoint
instruct CallLeafDirect(method meth)
%{
  match(CallLeaf);

  ins_cost(1);
  format %{ "call,leaf,runtime " %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Call runtime without safepoint
instruct CallLeafNoFPDirect(method meth)
%{
  match(CallLeafNoFP);

  ins_cost(1);
  format %{ "call,leaf_no_fp,runtime " %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Return Instruction
// Remove the return address & jump to it.
// Notice: We always emit a nop after a ret to make sure there is room
// for safepoint patching
instruct Ret()
%{
  match(Return);

  format %{ "return ctpr3\t#return prepare\n\t"
            "ct ctpr3\t#do return" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Tail Call; Jump from runtime stub to Java code.
// Also known as an 'interprocedural jump'.
// Target of jump will eventually return to caller.
// TailJump below removes the return address.
instruct TailCalljmpInd(regP jump_target, regP method_oop)
%{
  match(TailCall jump_target method_oop);

  ins_cost(300);
  format %{ "TailCall     $jump_target\t# rbx holds method oop" %}
  ins_encode();
  ins_pipe(empty);
%}

// Tail Jump; remove the return address; jump to target.
// TailCall above leaves the return address around.
instruct tailjmpInd(regP jump_target, regP ex_oop)
%{
  match(TailJump jump_target ex_oop);

  ins_cost(300);
  format %{ "TailJump     $jump_target" %}
  ins_encode();
  ins_pipe(empty);
%}

// Create exception oop: created by stack-crawling runtime code.
// Created exception is now available to this handler, and is setup
// just prior to jumping to this handler.  No code emitted.
instruct CreateException(regP ex_oop)
%{
  match(Set ex_oop (CreateEx));

  // use the following format syntax
  format %{ "mov g5, $ex_oop\t# save exception\n\t"
            "mov 0, g5\t# clear g5" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Rethrow exception:
// The exception oop will come in the first argument position.
// Then JUMP (not call) to the rethrow stub code.
instruct RethrowException()
%{
  match(Rethrow);

  // use the following format syntax
  format %{ "Rethrow Exception" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


// ============================================================================
// This name is KNOWN by the ADLC and cannot be changed.
// The ADLC forces a 'TypeRawPtr::BOTTOM' output type
// for this guy.
instruct tlsLoadP(regP dst) %{
  match(Set dst (ThreadLocal));

  format %{ "# TLS is in g3" %}
  ins_encode( /*empty encoding*/ );
  ins_pipe(empty);
%}


//----------SMARTSPILL RULES---------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.
//
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//


//----------SOURCE BLOCK-------------------------------------------------------
// This is a block of C++ code which provides values, functions, and
// definitions necessary in the rest of the architecture description
source_hpp %{
// Header information of the source block.
// Method declarations/definitions which are used outside
// the ad-scope can conveniently be defined here.
//
// To keep related declarations/definitions/uses close together,
// we switch between source %{ }% and source_hpp %{ }% freely as needed.

class CallStubImpl {

  //--------------------------------------------------------------
  //---<  Used for optimization in Compile::shorten_branches  >---
  //--------------------------------------------------------------

 public:
  // Size of call trampoline stub.
  static uint size_call_trampoline() {
    return 0; // no call trampolines on this platform
  }

  // number of relocations needed by a call trampoline stub
  static uint reloc_call_trampoline() {
    return 0; // no call trampolines on this platform
  }
};

class HandlerImpl {

 public:

  static int emit_exception_handler(CodeBuffer &cbuf);
  static int emit_deopt_handler(CodeBuffer& cbuf);

  static uint size_exception_handler() {
    // NativeCall instruction size is the same as NativeJump.
    // exception handler starts out as jump and can be patched to
    // a call be deoptimization.  (4932387)
    // Note that this value is also credited (in output.cpp) to
    // the size of the code section.
    return 0;
  }

#ifdef _LP64
  static uint size_deopt_handler() {
    // three 5 byte instructions
    return 0;
  }
#else
  static uint size_deopt_handler() {
    // NativeCall instruction size is the same as NativeJump.
    // exception handler starts out as jump and can be patched to
    // a call be deoptimization.  (4932387)
    // Note that this value is also credited (in output.cpp) to
    // the size of the code section.
    return 0;
  }
#endif
};

%} // end source_hpp
source %{

// Emit exception handler code.
// Stuff framesize into a register and call a VM stub routine.
int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {
  return 0;
}

// Emit deopt handler code.
int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {
  return 0;
}


//=============================================================================

const bool Matcher::match_rule_supported(int opcode) {
  return  has_match_rule(opcode);
}

// Max vector size in bytes. 0 if not supported.
const int Matcher::vector_width_in_bytes(BasicType bt) {
  return 8;
}

// Limits on vector size (number of elements) loaded into vector.
const int Matcher::max_vector_size(const BasicType bt) {
  return vector_width_in_bytes(bt)/type2aelembytes(bt);
}
const int Matcher::min_vector_size(const BasicType bt) {
  int max_size = max_vector_size(bt);
  // Min size which can be loaded into vector is 4 bytes.
  int size = (type2aelembytes(bt) == 1) ? 4 : 2;
  return MIN2(size,max_size);
}

// Vector ideal reg corresponding to specidied size in bytes
const int Matcher::vector_ideal_reg(int size) {
  assert(MaxVectorSize >= size, "");
  switch(size) {
    case  4: return Op_VecS;
    case  8: return Op_VecD;
    case 16: return Op_VecX;
    case 32: return Op_VecY;
  }
  ShouldNotReachHere();
  return 0;
}

// Only lowest bits of xmm reg are used for vector shift count.
const int Matcher::vector_shift_count_ideal_reg(int size) {
  return Op_VecS;
}

// x86 supports misaligned vectors store/load.
const bool Matcher::misaligned_vectors_ok() {
  return !AlignVector; // can be changed by flag
}

// x86 AES instructions are compatible with SunJCE expanded
// keys, hence we do not need to pass the original key to stubs
const bool Matcher::pass_original_key_for_aes() {
  return false;
}

#ifndef PRODUCT
  void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {
    st->print("nop \t# %d bytes pad for loops and calls", _count);
  }
#endif

  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {
    MacroAssembler _masm(&cbuf);
    __ nop(_count);
  }

  uint MachNopNode::size(PhaseRegAlloc*) const {
    return _count;
  }

#ifndef PRODUCT
  void MachBreakpointNode::format(PhaseRegAlloc*, outputStream* st) const {
    st->print("# breakpoint");
  }
#endif

  void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc* ra_) const {}

  uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {}

%}

// INSTRUCTIONS -- Platform independent definitions (same for 32- and 64-bit)

// ============================================================================

instruct ShouldNotReachHere() %{
  match(Halt);
  format %{ "ShouldNotReachHere" %}
  ins_encode();
  ins_pipe(empty);
%}

// ============================================================================

instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (AddF src1 src2));

  format %{ "fadds   $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct addF_reg_imm(regF dst, regF src, immF con) %{
  match(Set dst (AddF src con));

  format %{ "fadds   $src, $con, $dst\t# load from constant table: float=$con" %}
  ins_cost(150);
  ins_encode();
  ins_pipe(empty);
%}

instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (AddD src1 src2));

  format %{ "faddd  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct addD_reg_imm(regD dst, regD src, immD con) %{
  match(Set dst (AddD src con));

  format %{ "faddd  $src, $con, $dst\t# load from constant table: double=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (SubF src1 src2));

  format %{ "fsubs  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct subF_reg_imm(regF dst, regF src, immF con) %{
  match(Set dst (SubF src con));

  format %{ "fsubs  $src, $con, $dst\t# load from constant table: float=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (SubD src1 src2));

  format %{ "fsubd  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct subD_reg_imm(regD dst, regD src, immD con) %{
  match(Set dst (SubD src con));

  format %{ "fsubd  $src, $con, $dst\t# load from constant table: double=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (MulF src1 src2));

  format %{ "fmuls  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct mulF_reg_imm(regF dst, regF src, immF con) %{
  match(Set dst (MulF src con));

  format %{ "fmuls  $src, $con, $dst\t# load from constant table: float=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (MulD src1 src2));

  format %{ "fmuld  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct mulD_reg_imm(regD dst, regD src, immD con) %{
  match(Set dst (MulD src con));

  format %{ "fmuld  $src, $con, $dst\t# load from constant table: double=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (DivF src1 src2));

  format %{ "fdivs  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct divF_reg_imm(regF dst, regF src, immF con) %{
  match(Set dst (DivF src con));

  format %{ "fdivs  $src, $con, $dst\t# load from constant table: float=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct divF_F1_reg(regF dst, immF1 one, regF src) %{
  match(Set dst (DivF one src));

  format %{ "frcp  $src, $dst\t# 1/$src" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (DivD src1 src2));

  format %{ "fdivd  $src1, $src2, $dst" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct divD_reg_imm(regD dst, regD src, immD con) %{
  match(Set dst (DivD src con));

  format %{ "fdivd  $src, $con, $dst\t# load from constant table: double=$con" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct absF_reg_reg(regF dst, regF src) %{
  match(Set dst (AbsF src));

  ins_cost(1);
  format %{ "fcmples $src, 0, prexX\n\t"
            "xors $src, 0x80000000, tmp\n\t"
            "merges $src, tmp, $dst ? predX\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct absD_reg_reg(regD dst, regD src) %{
  match(Set dst (AbsD src));

  ins_cost(1);
  format %{ "fcmpled $src, 0, prexX\n\t"
            "xord $src, 0x8000000000000000, tmp\n\t"
            "merged $src, tmp, $dst ? predX\n\t" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct negF_reg_reg(regF dst, regF src) %{
  match(Set dst (NegF src));
  ins_cost(1);
  format %{ "xors  $src, 0x80000000, $dst\t# neg float by sign flipping" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct negD_reg_reg(regD dst, regD src) %{
  match(Set dst (NegD src));
  ins_cost(1);
  format %{ "xord  $src, 0x8000000000000000, $dst\t"
            "# neg double by sign flipping" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct sqrtF_reg(regF dst, regF src) %{
  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));

  format %{ "fsqrts  $src, $dst" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct rsqrtF1_reg(regF dst, regF src, immF1 one) %{
  match(Set dst (DivF one (ConvD2F (SqrtD (ConvF2D src)))));

  format %{ "frsqrts  $src, $dst" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct rsqrtD1_reg(regF dst, regF src, immD1 one) %{
  match(Set dst (ConvD2F (DivD one (SqrtD (ConvF2D src)))));

  format %{ "frsqrts  $src, $dst" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct sqrtF_imm(regF dst, immF con) %{
  match(Set dst (ConvD2F (SqrtD (ConvF2D con))));
  format %{ "fsqrt  $con, $dst\t# load from constant table: float=$con" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct sqrtD_reg(regD dst, regD src) %{
  match(Set dst (SqrtD src));

  format %{ "fsqrtid  $src, $dst\t# 1st step"
            "fsqrttd  $src, $dst, $dst\t# 2nd step" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}


instruct sqrtD_imm(regD dst, immD con) %{
  match(Set dst (SqrtD con));

  format %{ "movd  $con, tmp\t# for src1\n\t"
            "fsqrtid  $con, $dst\t# 1st step\n\t"
            "fsqrttd  tmp, $dst, $dst\t# 2nd step" %}
  ins_cost(1);
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

// Load vectors (4 bytes long)
instruct loadV4(vecS dst, memory mem) %{
  predicate(n->as_LoadVector()->memory_size() == 4);
  match(Set dst (LoadVector mem));
  ins_cost(1);
  format %{ "movd    $dst,$mem\t! load vector (4 bytes)" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

// Load vectors (8 bytes long)
instruct loadV8(vecD dst, memory mem) %{
  predicate(n->as_LoadVector()->memory_size() == 8);
  match(Set dst (LoadVector mem));
  ins_cost(1);
  format %{ "movq    $dst,$mem\t! load vector (8 bytes)" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

// Store vectors
instruct storeV4(memory mem, vecS src) %{
  predicate(n->as_StoreVector()->memory_size() == 4);
  match(Set mem (StoreVector mem src));
  ins_cost(1);
  format %{ "movd    $mem,$src\t! store vector (4 bytes)" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

instruct storeV8(memory mem, vecD src) %{
  predicate(n->as_StoreVector()->memory_size() == 8);
  match(Set mem (StoreVector mem src));
  ins_cost(1);
  format %{ "movq    $mem,$src\t! store vector (8 bytes)" %}
  ins_encode(  /*empty*/ );
  ins_pipe( empty );
%}

// Replicate integer (4 byte) scalar to be vector
instruct Repl2I(vecD dst, regI src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (ReplicateI src));
  format %{ "movd    $dst,$src\n\t"
            "pshufd  $dst,$dst,0x00\t! replicate2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct Repl4S(vecD dst, regI src) %{
  predicate(n->as_Vector()->length() == 4);
  match(Set dst (ReplicateS src));
  format %{ "movd    $dst,$src\n\t"
            "punpcklbw $dst,$dst\n\t"
            "pshuflw $dst,$dst,0x00\t! replicate4S" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct Repl4B(vecS dst, regI src) %{
  predicate(n->as_Vector()->length() == 4);
  match(Set dst (ReplicateB src));
  format %{ "movd    $dst,$src\n\t"
            "punpcklbw $dst,$dst\n\t"
            "pshuflw $dst,$dst,0x00\t! replicate4B" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct Repl8B(vecD dst, regI src) %{
  predicate(n->as_Vector()->length() == 8);
  match(Set dst (ReplicateB src));
  format %{ "movd    $dst,$src\n\t"
            "punpcklbw $dst,$dst\n\t"
            "pshuflw $dst,$dst,0x00\t! replicate8B" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Replicate float (4 byte) scalar to be vector
instruct Repl2F(vecD dst, regF src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (ReplicateF src));
  format %{ "pshufd  $dst,$dst,0x00\t! replicate2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Integers vector add
instruct vadd2I(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (AddVI dst src));
  format %{ "paddd   $dst,$src\t! add packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vadd2I_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (AddVI src1 src2));
  format %{ "vpaddd  $dst,$src1,$src2\t! add packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vadd4S(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 4);
  match(Set dst (AddVI dst src));
  format %{ "paddd   $dst,$src\t! add packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vadd4S_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 4);
  match(Set dst (AddVI src1 src2));
  format %{ "vpaddd  $dst,$src1,$src2\t! add packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vadd8B(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 8);
  match(Set dst (AddVI dst src));
  format %{ "paddd   $dst,$src\t! add packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vadd8B_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 8);
  match(Set dst (AddVI src1 src2));
  format %{ "vpaddd  $dst,$src1,$src2\t! add packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Integers vector sub
instruct vsub2I(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (SubVI dst src));
  format %{ "psubd   $dst,$src\t! sub packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vsub2I_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (SubVI src1 src2));
  format %{ "vpsubd  $dst,$src1,$src2\t! sub packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Integers vector mul
instruct vmul2I(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (MulVI dst src));
  format %{ "pmulld  $dst,$src\t! mul packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vmul2I_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (MulVI src1 src2));
  format %{ "vpmulld $dst,$src1,$src2\t! mul packed2I" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Floats vector add
instruct vadd2F(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (AddVF dst src));
  format %{ "addps   $dst,$src\t! add packed2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vadd2F_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (AddVF src1 src2));
  format %{ "vaddps  $dst,$src1,$src2\t! add packed2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Floats vector sub
instruct vsub2F(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (SubVF dst src));
  format %{ "subps   $dst,$src\t! sub packed2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vsub2F_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (SubVF src1 src2));
  format %{ "vsubps  $dst,$src1,$src2\t! sub packed2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

// Floats vector mul
instruct vmul2F(vecD dst, vecD src) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (MulVF dst src));
  format %{ "mulps   $dst,$src\t! mul packed2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}

instruct vmul2F_reg(vecD dst, vecD src1, vecD src2) %{
  predicate(n->as_Vector()->length() == 2);
  match(Set dst (MulVF src1 src2));
  format %{ "vmulps  $dst,$src1,$src2\t! mul packed2F" %}
  ins_encode( /*empty*/ );
  ins_pipe( empty );
%}


//----------Combined Instructions----------------------------------------------
//----------Integer combined Instructions----------------------------------------------

instruct shl_add_I_rrr(regI dst, regI src1, regI src2, regI src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddI src3 (LShiftI src1 src2)));

  format %{ "shl_add_s    $src1, $src2, $src3, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct shl_add_I_rir(regI dst, regI src1, immI src2, regI src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddI src3 (LShiftI src1 src2)));

  format %{ "shl_add_s    $src1, $src2, $src3, $dst\t# int" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct shl_add_L_rrr(regL dst, regI src1, regL src2, regL src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddL src3 (LShiftL src1 src2)));

  format %{ "shl_add_d    $src1, $src2, $src3, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct shl_add_L_rir(regL dst, regL src1, immI src2, regL src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddL src3 (LShiftL src1 src2)));

  format %{ "shl_add_d    $src1, $src2, $src3, $dst\t# long" %}
  ins_encode(  /*empty*/ );
  ins_pipe(empty);
%}

instruct shl_add_P_index_rir(regP dst, regI src1, immI src2, regP src3)
%{
  predicate(UseCombinedOps && (n->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0));
  match(Set dst (AddP src3 (LShiftL (ConvI2L src1) src2)));

  format %{ "shl_add_p    $src1, $src2, $src3, $dst\t# ptr" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}


instruct shl_add_P_rir(regP dst, regL src1, immI src2, regP src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddP src3 (LShiftL src1 src2)));

  format %{ "shl_add_p    $src1, $src2, $src3, $dst\t# ptr" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}


//----------Float combined Instructions----------------------------------------------

instruct fadd_fadd_F_rrr(regF dst, regF src1, regF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddF src3 (AddF src1 src2)));

  format %{ "fadd_fadd_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fadd_fadd_F_rir(regF dst, regF src1, immF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddF src3 (AddF src1 src2)));

  format %{ "fadd_fadd_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fadd_F_rrr(regF dst, regF src1, regF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddF src3 (SubF src1 src2)));

  format %{ "fsub_fadd_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fadd_F_rir(regF dst, regF src1, immF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddF src3 (SubF src1 src2)));

  format %{ "fsub_fadd_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fadd_F_rrr(regF dst, regF src1, regF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddF src3 (MulF src1 src2)));

  format %{ "fmul_fadd_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fadd_F_rir(regF dst, regF src1, immF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddF src3 (MulF src1 src2)));

  format %{ "fmul_fadd_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fadd_fsub_F_rrr(regF dst, regF src1, regF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubF src3 (AddF src1 src2)));

  format %{ "fadd_fsub_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fadd_fsub_F_rir(regF dst, regF src1, immF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubF src3 (AddF src1 src2)));

  format %{ "fadd_fsub_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fsub_F_rrr(regF dst, regF src1, regF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubF src3 (SubF src1 src2)));

  format %{ "fsub_fsub_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fsub_F_rir(regF dst, regF src1, immF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubF src3 (SubF src1 src2)));

  format %{ "fsub_fsub_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fsub_F_rrr(regF dst, regF src1, regF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubF src3 (MulF src1 src2)));

  format %{ "fmul_fsub_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fsub_F_rir(regF dst, regF src1, immF src2, regF src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubF src3 (MulF src1 src2)));

  format %{ "fmul_fsub_s    $src1, $src2, $src3, $dst\t# float" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

//----------Double combined Instructions----------------------------------------------

instruct fadd_fadd_D_rrr(regD dst, regD src1, regD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddD src3 (AddD src1 src2)));

  format %{ "fadd_fadd_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fadd_fadd_D_rir(regD dst, regD src1, immD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddD src3 (AddD src1 src2)));

  format %{ "fadd_fadd_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fadd_D_rrr(regD dst, regD src1, regD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddD src3 (SubD src1 src2)));

  format %{ "fsub_fadd_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fadd_D_rir(regD dst, regD src1, immD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddD src3 (SubD src1 src2)));

  format %{ "fsub_fadd_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fadd_D_rrr(regD dst, regD src1, regD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddD src3 (MulD src1 src2)));

  format %{ "fmul_fadd_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fadd_D_rir(regD dst, regD src1, immD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (AddD src3 (MulD src1 src2)));

  format %{ "fmul_fadd_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fadd_fsub_D_rrr(regD dst, regD src1, regD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubD src3 (AddD src1 src2)));

  format %{ "fadd_fsub_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fadd_fsub_D_rir(regD dst, regD src1, immD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubD src3 (AddD src1 src2)));

  format %{ "fadd_fsub_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fsub_D_rrr(regD dst, regD src1, regD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubD src3 (SubD src1 src2)));

  format %{ "fsub_fsub_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fsub_fsub_D_rir(regD dst, regD src1, immD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubD src3 (SubD src1 src2)));

  format %{ "fsub_fsub_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fsub_D_rrr(regD dst, regD src1, regD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubD src3 (MulD src1 src2)));

  format %{ "fmul_fsub_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}

instruct fmul_fsub_D_rir(regD dst, regD src1, immD src2, regD src3)
%{
  predicate(UseCombinedOps);
  match(Set dst (SubD src3 (MulD src1 src2)));

  format %{ "fmul_fsub_d    $src1, $src2, $src3, $dst\t# double" %}
  ins_cost(1);
  ins_encode();
  ins_pipe(empty);
%}
